<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>rquery Introduction • rquery</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script><script src="../pkgdown.js"></script><!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-vignette">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">rquery</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="..//index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/AssigmentPartitioner.html">Assignment Paritioner</a>
    </li>
    <li>
      <a href="../articles/QueryGeneration.html">Query Generation</a>
    </li>
    <li>
      <a href="../articles/rquery_intro.html">rquery Introduction</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">News</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="http://www.win-vector.com/">Sponsor: Win-Vector LLC</a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9">
    <div class="page-header toc-ignore">
      <h1>rquery Introduction</h1>
                        <h4 class="author">John Mount, Win-Vector LLC</h4>
            
            <h4 class="date">2018-03-09</h4>
          </div>

    
    
<div class="contents">
<div id="introduction" class="section level1">
<h1 class="hasAnchor">
<a href="#introduction" class="anchor"></a>Introduction</h1>
<p><a href="https://github.com/WinVector/rquery"><code>rquery</code></a> is a <a href="https://en.wikipedia.org/wiki/SQL"><code>SQL</code></a> query generator for <a href="https://www.r-project.org"><code>R</code></a>. It is based on <a href="https://en.wikipedia.org/wiki/Relational_algebra">Edgar F. Codd’s relational algebra</a> plus experience using <code>SQL</code> and <a href="https://CRAN.R-project.org/package=dplyr"><code>dplyr</code></a> at big data scale. The design represents an attempt to make <code>SQL</code> more teachable by denoting composition by a sequential pipeline notation instead of nested queries or functions. The implementation delivers reliable high performance data processing on large data systems such as <code>Spark</code> and databases. Package features include: data processing trees or pipelines as observable objects (able to report both columns produced and columns used), optimized <code>SQL</code> generation as an explicit user visible modeling step, convenience methods for applying query trees to in-memory <code>data.frame</code>s, and low direct package dependencies.</p>
</div>
<div id="pipeable-sql" class="section level1">
<h1 class="hasAnchor">
<a href="#pipeable-sql" class="anchor"></a>Pipeable <code>SQL</code>
</h1>
<p><code>SQL</code> is a very powerful data processing (or data engineering) grammar. Data scientists are well advised to learn to work with <code>SQL</code>.</p>
<p>An inessential difficulty in using <code>SQL</code> is <code>SQL</code> represents composition of operations by nesting, which can rapidly become confusing and illegible.</p>
<p>Let’s set up our environment so we can work with examples.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">library</span>(<span class="st">"rquery"</span>)</a></code></pre></div>
<pre><code>## Loading required package: wrapr</code></pre>
<pre><code>## Loading required package: DBI</code></pre>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="co"># example database connection</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">db &lt;-<span class="st"> </span>DBI<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/DBI/topics/dbConnect">dbConnect</a></span>(RSQLite<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/RSQLite/topics/SQLite">SQLite</a></span>(),</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">                     <span class="st">":memory:"</span>)</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">RSQLite<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/RSQLite/topics/initExtension">initExtension</a></span>(db)</a>
<a class="sourceLine" id="cb4-5" data-line-number="5"></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="co"># example data</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7">d &lt;-<span class="st"> </span><span class="kw"><a href="../reference/dbi_copy_to.html">dbi_copy_to</a></span>(</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">  db, <span class="st">'d'</span>,</a>
<a class="sourceLine" id="cb4-9" data-line-number="9">  <span class="kw">data.frame</span>(<span class="dt">v =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">-5</span>, <span class="dv">3</span>)),</a>
<a class="sourceLine" id="cb4-10" data-line-number="10">  <span class="dt">temporary =</span> <span class="ot">FALSE</span>,</a>
<a class="sourceLine" id="cb4-11" data-line-number="11">  <span class="dt">overwrite =</span> <span class="ot">TRUE</span>)</a></code></pre></div>
<p><code>d</code> is a “table description” which is just the name of a table and the names of expected columns. <code>d</code> does not store data or a database reference (making it safe to serialize/de-serialize). All <code>rquery</code> operation trees or pipelines must start either with a table description or a <code>data.frame</code>. We will discuss table descriptions later.</p>
<p>For our first example we will introduce a new column and perform a calculation using this column. This is achieved in <code>SQL</code> by writing code in one of two styles: defining the first new column twice (once to land the value and once to use), or sequencing two queries by nesting. We will demonstrate both methods.</p>
<p>The define the column twice solution looks like the following.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb5-1" data-line-number="1">DBI<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/DBI/topics/dbGetQuery">dbGetQuery</a></span>(db, <span class="st">"</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="st">  SELECT</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="st">    *,</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="st">    ABS(v) AS absv,</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="st">    ABS(v) - v AS delta</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="st">  FROM</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="st">    d</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"><span class="st">"</span>)</a></code></pre></div>
<pre><code>##    v absv delta
## 1  1    1     0
## 2 -5    5    10
## 3  3    3     0</code></pre>
<p>In <code>SQL</code> the column <code>absv</code> is not available for calculation in the same query that it is produced.</p>
<p>The nested method looks like the following, we produce the column <code>absv</code> in one query and then wrap that in another query to later use the column. For expressions longer than <code>ABS(v)</code> this is the preferred solution.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb7-1" data-line-number="1">DBI<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/DBI/topics/dbGetQuery">dbGetQuery</a></span>(db, <span class="st">"</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="st">  SELECT</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="st">    *,</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4"><span class="st">    absv - v AS delta</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5"><span class="st">  FROM (</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6"><span class="st">    SELECT</span></a>
<a class="sourceLine" id="cb7-7" data-line-number="7"><span class="st">      *,</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8"><span class="st">      ABS(v) AS absv</span></a>
<a class="sourceLine" id="cb7-9" data-line-number="9"><span class="st">    FROM</span></a>
<a class="sourceLine" id="cb7-10" data-line-number="10"><span class="st">      d</span></a>
<a class="sourceLine" id="cb7-11" data-line-number="11"><span class="st">  ) subtab</span></a>
<a class="sourceLine" id="cb7-12" data-line-number="12"><span class="st">"</span>)</a></code></pre></div>
<pre><code>##    v absv delta
## 1  1    1     0
## 2 -5    5    10
## 3  3    3     0</code></pre>
<div id="sql_node" class="section level2">
<h2 class="hasAnchor">
<a href="#sql_node" class="anchor"></a><code><a href="../reference/sql_node.html">sql_node()</a></code>
</h2>
<p>Using <code>rquery</code> we can write the <code>SQL</code> composition using pipe notation (where composition is written as <code>x %.&gt;% f %.&gt;% g</code> instead of <code>g(f(x))</code>). We are going to use <a href="https://github.com/WinVector/wrapr"><code>wrapr</code></a> <a href="https://winvector.github.io/wrapr/reference/grapes-.-greater-than-grapes.html">dot-pipe</a> instead of the <a href="https://CRAN.R-project.org/package=magrittr"><code>magrittr</code></a> pipe to pick up a neat feature we will use later (with the exception of that feature all examples will work with the <code>magrittr</code> pipe).</p>
<p>The <code>rquery</code> realization of the above calculation is as follows:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb9-1" data-line-number="1">op_tree &lt;-<span class="st"> </span>d <span class="op">%.&gt;%</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="st">  </span><span class="kw"><a href="../reference/sql_node.html">sql_node</a></span>(., <span class="st">"absv"</span> <span class="op">:</span><span class="er">=</span><span class="st"> "ABS(v)"</span>) <span class="op">%.&gt;%</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="st">  </span><span class="kw"><a href="../reference/sql_node.html">sql_node</a></span>(., <span class="st">"delta"</span> <span class="op">:</span><span class="er">=</span><span class="st"> "absv - v"</span>)</a>
<a class="sourceLine" id="cb9-4" data-line-number="4"><span class="kw"><a href="../reference/execute.html">execute</a></span>(db, op_tree)</a></code></pre></div>
<pre><code>##    v absv delta
## 1  1    1     0
## 2 -5    5    10
## 3  3    3     0</code></pre>
<p>The above is what we call “piped <code>SQL</code>” and represents a major convenience for users as the details of how to compose the statements are left to the package.</p>
<p>We can view the <code>SQL</code> translation of the operations tree as follows:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">cat</span>(<span class="kw"><a href="../reference/to_sql.html">to_sql</a></span>(op_tree, db))</a></code></pre></div>
<pre><code>SELECT
 *,
 absv - v AS `delta`
FROM (
 SELECT
  *,
  ABS(v) AS `absv`
 FROM (
  SELECT
   `d`.`v`
  FROM
   `d`
 ) tsql_66282161350309445814_0000000000
) tsql_66282161350309445814_0000000001</code></pre>
<p>Notice the above translations did not add identifier quotes to our use of “<code>v</code>” in “<code>ABS(v)</code>”. This is because the <code>SQL</code> expression is not parsed in <code>R</code>. If we want to identify terms as variables we can wrap them with <code>as.name()</code> or <code>quote()</code> to get the quoting (and other variable oriented features). The extra <code>SELECT</code> step to pull data from the inner table is used by <code>rquery</code> for important column narrowing steps, and can actually improve query performance.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb13-1" data-line-number="1">op_tree &lt;-<span class="st"> </span>d <span class="op">%.&gt;%</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="st">  </span><span class="kw"><a href="../reference/sql_node.html">sql_node</a></span>(., <span class="st">"absv"</span> <span class="op">:</span><span class="er">=</span><span class="st"> </span><span class="kw">list</span>(<span class="kw">list</span>(<span class="st">"ABS("</span>, <span class="kw">quote</span>(v), <span class="st">")"</span>))) <span class="op">%.&gt;%</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3"><span class="st">  </span><span class="kw"><a href="../reference/sql_node.html">sql_node</a></span>(., <span class="st">"delta"</span> <span class="op">:</span><span class="er">=</span><span class="st"> </span><span class="kw">list</span>(<span class="kw">list</span>(<span class="kw">quote</span>(absv),<span class="st">"-"</span>, <span class="kw">quote</span>(v))))</a>
<a class="sourceLine" id="cb13-4" data-line-number="4"><span class="kw">cat</span>(<span class="kw"><a href="../reference/to_sql.html">to_sql</a></span>(op_tree, db))</a></code></pre></div>
<pre><code>SELECT
 *,
 `absv` - `v` AS `delta`
FROM (
 SELECT
  *,
  ABS( `v` ) AS `absv`
 FROM (
  SELECT
   `d`.`v`
  FROM
   `d`
 ) tsql_40438848856750327953_0000000000
) tsql_40438848856750327953_0000000001</code></pre>
<p>The <code>list(list())</code> notation is how we say in <code>R</code> that we have a single element list (i.e. one expression) that is built up as a list of terms. The marking notation is cumbersome, but is not needed when we move on to relation nodes, which are parsed in <code>R</code> and can spot identifiers without additional help.</p>
<p><code>op_tree</code> itself is a an object with its own presentation format:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">print</span>(op_tree)</a></code></pre></div>
<pre><code>## [1] "table('d') %.&gt;% sql_node(., absv := ABS( v ), *=TRUE) %.&gt;% sql_node(., delta := absv - v, *=TRUE)"</code></pre>
<p><code>op_tree</code> stores an number of important summaries about the proposed query:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw"><a href="../reference/column_names.html">column_names</a></span>(op_tree)</a></code></pre></div>
<pre><code>## [1] "delta" "absv"  "v"</code></pre>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="kw"><a href="../reference/tables_used.html">tables_used</a></span>(op_tree)</a></code></pre></div>
<pre><code>## [1] "d"</code></pre>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw"><a href="../reference/columns_used.html">columns_used</a></span>(op_tree)</a></code></pre></div>
<pre><code>## $d
## [1] "v"</code></pre>
<div id="composing-nodes" class="section level3">
<h3 class="hasAnchor">
<a href="#composing-nodes" class="anchor"></a>Composing nodes</h3>
<p>We can add nodes to an <code>op_tree</code> to build larger operator trees (or pipelines).</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb23-1" data-line-number="1">op_tree &lt;-<span class="st"> </span>op_tree <span class="op">%.&gt;%</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2"><span class="st">  </span><span class="kw"><a href="../reference/sql_node.html">sql_node</a></span>(., <span class="st">"prod"</span> <span class="op">:</span><span class="er">=</span><span class="st"> "absv * delta"</span>)</a>
<a class="sourceLine" id="cb23-3" data-line-number="3"></a>
<a class="sourceLine" id="cb23-4" data-line-number="4"><span class="kw">cat</span>(<span class="kw">format</span>(op_tree))</a></code></pre></div>
<pre><code>## table('d') %.&gt;%
##  sql_node(.,
##           absv := ABS( v ),
##              *=TRUE) %.&gt;%
##  sql_node(.,
##           delta := absv - v,
##              *=TRUE) %.&gt;%
##  sql_node(.,
##           prod := absv * delta,
##              *=TRUE)</code></pre>
<p>And, the <code>op_tree</code> record keeping can be used to catch potential errors early in pipeline construction. For example if we try to refer to a non-existent variable when adding an operator we get an thrown exception (note: a <code><a href="../reference/sql_node.html">sql_node()</a></code> being added must have its variables marked as above for pre-checking to occur, relational nodes will get this checking automatically).</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb25-1" data-line-number="1">op_tree &lt;-<span class="st"> </span>op_tree <span class="op">%.&gt;%</span></a>
<a class="sourceLine" id="cb25-2" data-line-number="2"><span class="st">  </span><span class="kw"><a href="../reference/sql_node.html">sql_node</a></span>(., <span class="st">"z"</span> <span class="op">:</span><span class="er">=</span><span class="st"> </span><span class="kw">list</span>(<span class="kw">list</span>(<span class="st">"1 + "</span>, <span class="kw">quote</span>(z))))</a></code></pre></div>
<pre><code>## Error in sql_node.relop(., `:=`("z", list(list("1 + ", quote(z))))): rquery::sql_node.relop undefined columns: z</code></pre>
</div>
<div id="a-non-trivial-example" class="section level3">
<h3 class="hasAnchor">
<a href="#a-non-trivial-example" class="anchor"></a>A non-trivial example</h3>
<p>We can express non-trivial operations in <code><a href="../reference/sql_node.html">sql_node()</a></code>s. For example we can build a node the calculates for each row how many columns contain <code>NA</code>/<code>NULL</code> as is demonstrated here.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="co"># example database connection</span></a>
<a class="sourceLine" id="cb27-2" data-line-number="2">my_db &lt;-<span class="st"> </span>DBI<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/DBI/topics/dbConnect">dbConnect</a></span>(RSQLite<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/RSQLite/topics/SQLite">SQLite</a></span>(),</a>
<a class="sourceLine" id="cb27-3" data-line-number="3">                        <span class="st">":memory:"</span>)</a>
<a class="sourceLine" id="cb27-4" data-line-number="4"><span class="co"># load up example data</span></a>
<a class="sourceLine" id="cb27-5" data-line-number="5">d2 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/dbi_copy_to.html">dbi_copy_to</a></span>(</a>
<a class="sourceLine" id="cb27-6" data-line-number="6">  my_db, <span class="st">'d2'</span>,</a>
<a class="sourceLine" id="cb27-7" data-line-number="7">  <span class="kw">data.frame</span>(<span class="dt">v1 =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="ot">NA</span>, <span class="dv">3</span>),</a>
<a class="sourceLine" id="cb27-8" data-line-number="8">             <span class="dt">v2 =</span> <span class="kw">c</span>(<span class="ot">NA</span>, <span class="st">"b"</span>, <span class="ot">NA</span>, <span class="st">"c"</span>),</a>
<a class="sourceLine" id="cb27-9" data-line-number="9">             <span class="dt">v3 =</span> <span class="kw">c</span>(<span class="ot">NA</span>, <span class="ot">NA</span>, <span class="dv">7</span>, <span class="dv">8</span>),</a>
<a class="sourceLine" id="cb27-10" data-line-number="10">             <span class="dt">stringsAsFactors =</span> <span class="ot">FALSE</span>))</a>
<a class="sourceLine" id="cb27-11" data-line-number="11"></a>
<a class="sourceLine" id="cb27-12" data-line-number="12"><span class="co"># look at table</span></a>
<a class="sourceLine" id="cb27-13" data-line-number="13"><span class="kw"><a href="../reference/execute.html">execute</a></span>(my_db, d2)</a></code></pre></div>
<pre><code>##   v1   v2 v3
## 1  1 &lt;NA&gt; NA
## 2  2    b NA
## 3 NA &lt;NA&gt;  7
## 4  3    c  8</code></pre>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="co"># get list of columns</span></a>
<a class="sourceLine" id="cb29-2" data-line-number="2">vars &lt;-<span class="st"> </span><span class="kw"><a href="../reference/column_names.html">column_names</a></span>(d2)</a>
<a class="sourceLine" id="cb29-3" data-line-number="3"><span class="kw">print</span>(vars)</a></code></pre></div>
<pre><code>## [1] "v1" "v2" "v3"</code></pre>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="co"># build a NA/NULLs per-row counting expression.</span></a>
<a class="sourceLine" id="cb31-2" data-line-number="2"><span class="co"># names are "quoted" by wrapping them with as.name().</span></a>
<a class="sourceLine" id="cb31-3" data-line-number="3"><span class="co"># constants can be quoted by an additional list wrapping.</span></a>
<a class="sourceLine" id="cb31-4" data-line-number="4">expr &lt;-<span class="st"> </span><span class="kw">lapply</span>(vars,</a>
<a class="sourceLine" id="cb31-5" data-line-number="5">               <span class="cf">function</span>(vi) {</a>
<a class="sourceLine" id="cb31-6" data-line-number="6">                 <span class="kw">list</span>(<span class="st">"+ (CASE WHEN ("</span>,</a>
<a class="sourceLine" id="cb31-7" data-line-number="7">                      <span class="kw">as.name</span>(vi),</a>
<a class="sourceLine" id="cb31-8" data-line-number="8">                      <span class="st">"IS NULL ) THEN 1.0 ELSE 0.0 END)"</span>)</a>
<a class="sourceLine" id="cb31-9" data-line-number="9">               })</a>
<a class="sourceLine" id="cb31-10" data-line-number="10">expr &lt;-<span class="st"> </span><span class="kw">unlist</span>(expr, <span class="dt">recursive =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb31-11" data-line-number="11">expr &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">list</span>(<span class="fl">0.0</span>), expr)</a>
<a class="sourceLine" id="cb31-12" data-line-number="12"><span class="kw">cat</span>(<span class="kw">paste</span>(<span class="kw">unlist</span>(expr), <span class="dt">collapse =</span> <span class="st">" "</span>))</a></code></pre></div>
<pre><code>## 0 + (CASE WHEN ( v1 IS NULL ) THEN 1.0 ELSE 0.0 END) + (CASE WHEN ( v2 IS NULL ) THEN 1.0 ELSE 0.0 END) + (CASE WHEN ( v3 IS NULL ) THEN 1.0 ELSE 0.0 END)</code></pre>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb33-1" data-line-number="1"><span class="co"># instantiate the operator node</span></a>
<a class="sourceLine" id="cb33-2" data-line-number="2">op_tree_count_null &lt;-<span class="st"> </span>d2 <span class="op">%.&gt;%</span></a>
<a class="sourceLine" id="cb33-3" data-line-number="3"><span class="st">  </span><span class="kw"><a href="../reference/sql_node.html">sql_node</a></span>(., <span class="st">"num_missing"</span> <span class="op">:</span><span class="er">=</span><span class="st"> </span><span class="kw">list</span>(expr))</a>
<a class="sourceLine" id="cb33-4" data-line-number="4"><span class="kw">cat</span>(<span class="kw">format</span>(op_tree_count_null))</a></code></pre></div>
<pre><code>## table('d2') %.&gt;%
##  sql_node(.,
##           num_missing := 0 + (CASE WHEN ( v1 IS NULL ) THEN 1.0 ELSE 0.0 END) + (CASE WHEN ( v2 IS NULL ) THEN 1.0 ELSE 0.0 END) + (CASE WHEN ( v3 IS NULL ) THEN 1.0 ELSE 0.0 END),
##              *=TRUE)</code></pre>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb35-1" data-line-number="1"><span class="co"># examine produced SQL</span></a>
<a class="sourceLine" id="cb35-2" data-line-number="2">sql &lt;-<span class="st"> </span><span class="kw"><a href="../reference/to_sql.html">to_sql</a></span>(op_tree_count_null, my_db)</a>
<a class="sourceLine" id="cb35-3" data-line-number="3"><span class="kw">cat</span>(sql)</a></code></pre></div>
<pre><code>## SELECT
##  *,
##  0 + (CASE WHEN ( `v1` IS NULL ) THEN 1.0 ELSE 0.0 END) + (CASE WHEN ( `v2` IS NULL ) THEN 1.0 ELSE 0.0 END) + (CASE WHEN ( `v3` IS NULL ) THEN 1.0 ELSE 0.0 END) AS `num_missing`
## FROM (
##  SELECT
##   `d2`.`v1`,
##   `d2`.`v2`,
##   `d2`.`v3`
##  FROM
##   `d2`
## ) tsql_07268216680626397697_0000000000</code></pre>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb37-1" data-line-number="1"><span class="co"># execute</span></a>
<a class="sourceLine" id="cb37-2" data-line-number="2"><span class="kw"><a href="../reference/execute.html">execute</a></span>(my_db, op_tree_count_null)</a></code></pre></div>
<pre><code>##   v1   v2 v3 num_missing
## 1  1 &lt;NA&gt; NA           2
## 2  2    b NA           1
## 3 NA &lt;NA&gt;  7           2
## 4  3    c  8           0</code></pre>
<p>And, as this is an important capability, this exact functionality is wrapped in <a href="https://winvector.github.io/rquery/reference/count_null_cols.html"><code><a href="../reference/count_null_cols.html">count_null_cols()</a></code></a>.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb39-1" data-line-number="1"><span class="co"># whole process wrapped in convenience node</span></a>
<a class="sourceLine" id="cb39-2" data-line-number="2">d2 <span class="op">%.&gt;%</span></a>
<a class="sourceLine" id="cb39-3" data-line-number="3"><span class="st">  </span><span class="kw"><a href="../reference/count_null_cols.html">count_null_cols</a></span>(., vars, <span class="st">"nnull"</span>) <span class="op">%.&gt;%</span></a>
<a class="sourceLine" id="cb39-4" data-line-number="4"><span class="st">  </span><span class="kw"><a href="../reference/execute.html">execute</a></span>(my_db, .)</a></code></pre></div>
<pre><code>##   v1   v2 v3 nnull
## 1  1 &lt;NA&gt; NA     2
## 2  2    b NA     1
## 3 NA &lt;NA&gt;  7     2
## 4  3    c  8     0</code></pre>
</div>
</div>
</div>
<div id="sql-first" class="section level1">
<h1 class="hasAnchor">
<a href="#sql-first" class="anchor"></a><code>SQL</code> first</h1>
<p><code>rquery</code> is a “<code>SQL</code> first” system. It is designed to create <code>SQL</code> queries and dispatch them to remote systems (<code>SQLite</code>, <code>Spark</code>, <code>PostgreSQL</code>, <code>Redshift</code>, and other databases) for execution. The <a href="https://winvector.github.io/rquery/reference/execute.html"><code><a href="../reference/execute.html">execute()</a></code></a> method can be used with big data by adding a <code>table_name</code> argument (or also by using the <a href="https://winvector.github.io/rquery/reference/materialize.html"><code><a href="../reference/materialize.html">materialize()</a></code></a> method) to land results in a remote table instead of pulling them back to <code>R</code>.</p>
<p>The mantra of <code>SQL</code>-first is data starts in the database, and stays in the database (i.e., it is too large to depend on round-tripping through <code>R</code>). Another important <code>SQL</code>-first package is <a href="https://github.com/WinVector/cdata/"><code>cdata</code></a> which provides pure <code>SQL</code> based implementations of operators that generalize pivot/un-pivot, cast/melt, or spread/gather.</p>
<p>The better the database implementation the better <code>rquery</code> will be, both in terms of performance and in terms of function (such as the availability of <code>SQL</code> window functions).</p>
</div>
<div id="ad-hoc-mode" class="section level1">
<h1 class="hasAnchor">
<a href="#ad-hoc-mode" class="anchor"></a>Ad-hoc mode</h1>
<p>As a convenience <code>rquery</code> can work with in-memory <code>data.frame</code>s by sending them to the <code>SQL</code> service provider. This provider defaults to <code>RSQlite</code> or can be set by setting the global variable <code>winvector_temp_db_handle</code>. We demonstrate this below.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb41-1" data-line-number="1">winvector_temp_db_handle &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">db =</span> db)</a>
<a class="sourceLine" id="cb41-2" data-line-number="2"></a>
<a class="sourceLine" id="cb41-3" data-line-number="3"><span class="kw">data.frame</span>(<span class="dt">v =</span> <span class="dv">-2</span><span class="op">:</span><span class="dv">2</span>) <span class="op">%.&gt;%</span></a>
<a class="sourceLine" id="cb41-4" data-line-number="4"><span class="st">  </span><span class="kw"><a href="../reference/execute.html">execute</a></span>(., op_tree)</a></code></pre></div>
<pre><code>##    v absv delta prod
## 1 -2    2     4    8
## 2 -1    1     2    2
## 3  0    0     0    0
## 4  1    1     0    0
## 5  2    2     0    0</code></pre>
<p>When using the <code>wrapr</code> dot pipe the above can be abbreviated as:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb43-1" data-line-number="1"><span class="kw">data.frame</span>(<span class="dt">v =</span> <span class="dv">-2</span><span class="op">:</span><span class="dv">2</span>) <span class="op">%.&gt;%</span><span class="st"> </span>op_tree</a></code></pre></div>
<pre><code>##    v absv delta prod
## 1 -2    2     4    8
## 2 -1    1     2    2
## 3  0    0     0    0
## 4  1    1     0    0
## 5  2    2     0    0</code></pre>
<p>The above calculation is managed by <a href="https://github.com/WinVector/wrapr/blob/master/extras/wrapr_pipe.pdf"><code>wrapr</code> dot pipe <code>S3</code> <code>wrapr_function</code></a> extensions.</p>
<p><code>rquery</code> operators can be used directly (without any table description nodes) when working with in-memory <code>data.frame</code>s.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb45-1" data-line-number="1"><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">5</span>) <span class="op">%.&gt;%</span><span class="st"> </span><span class="kw"><a href="../reference/sql_node.html">sql_node</a></span>(., <span class="st">"z"</span> <span class="op">:</span><span class="er">=</span><span class="st"> "sqrt(x)"</span>)</a></code></pre></div>
<pre><code>##   x        z
## 1 5 2.236068</code></pre>
<p>The above calculation is triggered by <code>S3</code> override of any of <code>print()</code>, <code>as.data.frame()</code> and <code>head()</code>. Remote tables need an <code>execuite()</code> or <code><a href="../reference/materialize.html">materialize()</a></code> step to specify the database connection.</p>
</div>
<div id="table-descriptions" class="section level1">
<h1 class="hasAnchor">
<a href="#table-descriptions" class="anchor"></a>Table descriptions</h1>
<p><code>rquery</code> table descriptions are simple objects that store only the name of a table and expected columns. Any local data or database table that has at least the set of columns named in the table description can be used in a given <code>rquery</code> pipeline.</p>
<p>The table description “<code>d</code>” we have been using in examples was produced as a result of moving data to a database by <a href="https://winvector.github.io/rquery/reference/dbi_copy_to.html"><code><a href="../reference/dbi_copy_to.html">dbi_copy_to()</a></code></a>. However we can also create a description of an existing table with <a href="https://winvector.github.io/rquery/reference/dbi_table.html"><code><a href="../reference/dbi_table.html">dbi_table()</a></code></a> or even build a description by hand with <a href="https://winvector.github.io/rquery/reference/table_source.html"><code><a href="../reference/table_source.html">table_source()</a></code></a>.</p>
</div>
<div id="operators" class="section level1">
<h1 class="hasAnchor">
<a href="#operators" class="anchor"></a>Operators</h1>
<p>The <a href="https://winvector.github.io/rquery/reference/sql_node.html"><code><a href="../reference/sql_node.html">sql_node()</a></code></a> alone can make writing, understanding, and maintaining complex data transformations as queries easier. And this node is a good introduction to some of the power of the <code>rquery</code> package. However, the primary purpose of <code>rquery</code> is to provide ready-made relational operators to further simplify to the point of rarely needing to use the <code><a href="../reference/sql_node.html">sql_node()</a></code> directly.</p>
<p>The primary operators supplied by <code>rquery</code> are:</p>
<p>The primary relational operators include:</p>
<ul>
<li>
<a href="https://winvector.github.io/rquery/reference/extend_nse.html"><code><a href="../reference/extend_nse.html">extend_nse()</a></code></a>/<a href="https://winvector.github.io/rquery/reference/extend_se.html"><code><a href="../reference/extend_se.html">extend_se()</a></code></a>. Extend adds derived columns to a relation table. With a sufficiently powerful <code>SQL</code> provider this includes ordered and partitioned window functions. This operator also includes built-in <a href="https://winvector.github.io/seplyr/"><code>seplyr</code></a>-style <a href="https://winvector.github.io/seplyr/articles/MutatePartitioner.html">assignment partitioning</a>.</li>
<li>
<a href="https://winvector.github.io/rquery/reference/project_nse.html"><code>project()</code></a>. Project is usually <em>portrayed</em> as the equivalent to column selection, though the original definition includes aggregation. In our opinion the original relational nature of the operator is best captured by moving <code>SQL</code>’s “<code>GROUP BY</code>” aggregation functionality.</li>
<li>
<a href="https://winvector.github.io/rquery/reference/natural_join.html"><code><a href="../reference/natural_join.html">natural_join()</a></code></a>. This a specialized relational join operator, using all common columns as an equi-join condition.</li>
<li>
<a href="https://winvector.github.io/rquery/reference/theta_join_nse.html"><code>theta_join()</code></a>. This is the relational join operator allowing an arbitrary predicate.</li>
<li>
<a href="https://winvector.github.io/rquery/reference/theta_join_nse.html"><code>select_rows()</code></a>. This is Codd’s relational row selection. Obviously <code>select</code> alone is an over-used and now ambiguous term (for example: it is already used as the “doit” verb in <code>SQL</code> and the <em>column</em> selector in <code>dplyr</code>).</li>
<li>
<a href="https://winvector.github.io/rquery/reference/rename_columns.html"><code><a href="../reference/rename_columns.html">rename_columns()</a></code></a>. This operator renames sets of columns.</li>
</ul>
<p>The primary non-relational (traditional <code>SQL</code>) operators are:</p>
<ul>
<li>
<a href="https://winvector.github.io/rquery/reference/select_columns.html"><code><a href="../reference/select_columns.html">select_columns()</a></code></a>. This allows choice of columns (central to <code>SQL</code>), but is not a relational operator as it can damage row-uniqueness.</li>
<li>
<a href="https://winvector.github.io/rquery/reference/orderby.html"><code><a href="../reference/orderby.html">orderby()</a></code></a>. Row order is not a concept in the relational algebra (and also not maintained in most <code>SQL</code> implementations). This operator is only useful when used with its <code>limit=</code> option, or as the last step as data comes out of the relation store and is moved to <code>R</code> (where row-order is usually maintained).</li>
</ul>
<p>The above list (and especially naming) are chosen to first match Codd’s relational concepts (<code>project</code>, <code>select</code>, <code>rename</code>, <code>join</code>, aggregation), <code>SQL</code> naming conventions. Notice this covers the <a href="http://dplyr.tidyverse.org">primary <code>dplyr</code> operators</a> <code>mutate()</code> (Codd’s <code>extend</code>), <code>select()</code> (not relational), <code>filter()</code> (Codd’s <code>select</code>, represented in <code>SQL</code> by “<code>WHERE</code>”), <code>summarise()</code> (Codd’s <code>project</code> or aggregate concepts, triggered in <code>SQL</code> by “<code>GROUP BY</code>”), <code>arrange()</code> (not a relational concept, implemented in <code>SQL</code> by “ORDER BY”). This correspondence is due to Codd’s ideas and <code>SQL</code> driving data engineering thinking for almost the last 50 years (both with and without credit or citation).</p>
<p>With relational operators the user can work fast and work further away from syntactic details. For example with a database that supplies window functions one can quickly work the “logistic scoring by hand” example from<br>
from <a href="http://www.win-vector.com/blog/2017/08/lets-have-some-sympathy-for-the-part-time-r-user/">Let’s Have Some Sympathy For The Part-time R User</a>. That example worked with <code>rquery</code> code that works with both <code>PostgreSQL</code> and <code>Spark</code> can be found <a href="https://github.com/WinVector/rquery/blob/master/README.md">here</a>.</p>
<p>We can demonstrate the pipeline, but the <code>SQLite</code> database we are using in this vignette does not have the window functions required to execute it. <code>PostgreSQL</code>, <code>Spark</code>, and many other databases do have the necessary functionality. The pipeline is a good example of a non-trivial sequence of relational nodes.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb47-1" data-line-number="1">scale &lt;-<span class="st"> </span><span class="fl">0.237</span></a>
<a class="sourceLine" id="cb47-2" data-line-number="2"></a>
<a class="sourceLine" id="cb47-3" data-line-number="3">dq &lt;-<span class="st"> </span><span class="kw"><a href="../reference/table_source.html">table_source</a></span>(<span class="st">"d3"</span>, </a>
<a class="sourceLine" id="cb47-4" data-line-number="4">                   <span class="dt">columns =</span> <span class="kw">qc</span>(subjectID, </a>
<a class="sourceLine" id="cb47-5" data-line-number="5">                                surveyCategory, </a>
<a class="sourceLine" id="cb47-6" data-line-number="6">                                assessmentTotal)) <span class="op">%.&gt;%</span></a>
<a class="sourceLine" id="cb47-7" data-line-number="7"><span class="st">  </span><span class="kw"><a href="../reference/extend_nse.html">extend_nse</a></span>(.,</a>
<a class="sourceLine" id="cb47-8" data-line-number="8">             probability <span class="op">:</span><span class="er">=</span></a>
<a class="sourceLine" id="cb47-9" data-line-number="9"><span class="st">               </span><span class="kw">exp</span>(assessmentTotal <span class="op">*</span><span class="st"> </span>scale)<span class="op">/</span></a>
<a class="sourceLine" id="cb47-10" data-line-number="10"><span class="st">               </span><span class="kw">sum</span>(<span class="kw">exp</span>(assessmentTotal <span class="op">*</span><span class="st"> </span>scale)),</a>
<a class="sourceLine" id="cb47-11" data-line-number="11">             count <span class="op">:</span><span class="er">=</span><span class="st"> </span><span class="kw">count</span>(<span class="dv">1</span>),</a>
<a class="sourceLine" id="cb47-12" data-line-number="12">             <span class="dt">partitionby =</span> <span class="st">'subjectID'</span>) <span class="op">%.&gt;%</span></a>
<a class="sourceLine" id="cb47-13" data-line-number="13"><span class="st">  </span><span class="kw"><a href="../reference/extend_nse.html">extend_nse</a></span>(.,</a>
<a class="sourceLine" id="cb47-14" data-line-number="14">             rank <span class="op">:</span><span class="er">=</span><span class="st"> </span><span class="kw">rank</span>(),</a>
<a class="sourceLine" id="cb47-15" data-line-number="15">             <span class="dt">partitionby =</span> <span class="st">'subjectID'</span>,</a>
<a class="sourceLine" id="cb47-16" data-line-number="16">             <span class="dt">orderby =</span> <span class="kw">c</span>(<span class="st">'probability'</span>, </a>
<a class="sourceLine" id="cb47-17" data-line-number="17">                         <span class="st">'surveyCategory'</span>))  <span class="op">%.&gt;%</span></a>
<a class="sourceLine" id="cb47-18" data-line-number="18"><span class="st">  </span><span class="kw"><a href="../reference/rename_columns.html">rename_columns</a></span>(., <span class="st">'diagnosis'</span> <span class="op">:</span><span class="er">=</span><span class="st"> 'surveyCategory'</span>) <span class="op">%.&gt;%</span></a>
<a class="sourceLine" id="cb47-19" data-line-number="19"><span class="st">  </span><span class="kw"><a href="../reference/select_rows_nse.html">select_rows_nse</a></span>(., rank <span class="op">==</span><span class="st"> </span>count) <span class="op">%.&gt;%</span></a>
<a class="sourceLine" id="cb47-20" data-line-number="20"><span class="st">  </span><span class="kw"><a href="../reference/select_columns.html">select_columns</a></span>(., <span class="kw">c</span>(<span class="st">'subjectID'</span>, </a>
<a class="sourceLine" id="cb47-21" data-line-number="21">                      <span class="st">'diagnosis'</span>, </a>
<a class="sourceLine" id="cb47-22" data-line-number="22">                      <span class="st">'probability'</span>)) <span class="op">%.&gt;%</span></a>
<a class="sourceLine" id="cb47-23" data-line-number="23"><span class="st">  </span><span class="kw"><a href="../reference/orderby.html">orderby</a></span>(., <span class="st">'subjectID'</span>)</a></code></pre></div>
<p><a href="https://winvector.github.io/wrapr/reference/qc.html"><code>qc()</code></a> is “quoting concatenate”, a convenience function that lets us skip a few quote marks. No <code>list()</code>, <code>as.name()</code>, or <code>quote()</code> steps are needed as the operator nodes are parsed by <code>R</code> to find identifiers.</p>
<p>Even though we are not going to run this query here, we can still check some properties of the query.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb48-1" data-line-number="1"><span class="kw"><a href="../reference/tables_used.html">tables_used</a></span>(dq)</a></code></pre></div>
<pre><code>## [1] "d3"</code></pre>
<div class="sourceCode" id="cb50"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb50-1" data-line-number="1"><span class="kw"><a href="../reference/columns_used.html">columns_used</a></span>(dq)</a></code></pre></div>
<pre><code>## $d3
## [1] "subjectID"       "surveyCategory"  "assessmentTotal"</code></pre>
<div class="sourceCode" id="cb52"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb52-1" data-line-number="1"><span class="kw"><a href="../reference/column_names.html">column_names</a></span>(dq)</a></code></pre></div>
<pre><code>## [1] "diagnosis"   "probability" "subjectID"</code></pre>
<p>To see the query executed, please see <a href="https://github.com/WinVector/rquery/blob/master/README.md">here</a>.</p>
</div>
<div id="non-sql-nodes" class="section level1">
<h1 class="hasAnchor">
<a href="#non-sql-nodes" class="anchor"></a>Non-<code>SQL</code> nodes</h1>
<p>Not all data transform steps can conveniently be written as a single <code>SQL</code> statement. To work around this potential limitation <code>rquery</code> supplies a special type of node called <a href="https://winvector.github.io/rquery/reference/non_sql_node.html"><code><a href="../reference/non_sql_node.html">non_sql_node()</a></code></a>. <code><a href="../reference/non_sql_node.html">non_sql_node()</a></code> is used to implement arbitrary table to table transforms as <code>rquery</code> pipeline steps. Two important examples of <code><a href="../reference/non_sql_node.html">non_sql_node()</a></code> are <a href="https://winvector.github.io/rquery/reference/materialize_node.html"><code><a href="../reference/materialize_node.html">materialize_node()</a></code></a> and <a href="https://winvector.github.io/rquery/reference/rsummary_node.html"><code><a href="../reference/rsummary_node.html">rsummary_node()</a></code></a>.</p>
<p><code><a href="../reference/materialize_node.html">materialize_node()</a></code> can be used to land intermediate results into a table. This can be used both to save intermediate calculation stages and to break up the complexity of long data processing pipelines.</p>
<p><code><a href="../reference/rsummary_node.html">rsummary_node()</a></code> builds a table of summary information about another database table. The format is each column of the original table produces a row of summary information in the result table. Here is a simple example.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb54-1" data-line-number="1">op_tree <span class="op">%.&gt;%</span></a>
<a class="sourceLine" id="cb54-2" data-line-number="2"><span class="st">  </span><span class="kw"><a href="../reference/rsummary_node.html">rsummary_node</a></span>(.) <span class="op">%.&gt;%</span></a>
<a class="sourceLine" id="cb54-3" data-line-number="3"><span class="st">  </span><span class="kw"><a href="../reference/execute.html">execute</a></span>(db, .)</a></code></pre></div>
<pre><code>##   column index   class nrows nna nunique min max       mean        sd
## 1      v     1 numeric     3   0      NA  -5   3 -0.3333333  4.163332
## 2   absv     2 numeric     3   0      NA   1   5  3.0000000  2.000000
## 3  delta     3 numeric     3   0      NA   0  10  3.3333333  5.773503
## 4   prod     4 numeric     3   0      NA   0  50 16.6666667 28.867513
##   lexmin lexmax
## 1     NA     NA
## 2     NA     NA
## 3     NA     NA
## 4     NA     NA</code></pre>
<p>Users can add additional capabilities by writing their own <code><a href="../reference/non_sql_node.html">non_sql_node()</a></code>s.</p>
</div>
<div id="standard-interfaces" class="section level1">
<h1 class="hasAnchor">
<a href="#standard-interfaces" class="anchor"></a>Standard interfaces</h1>
<p><code>rquery</code> goes out of its way to supply easy to program over value-oriented interfaces. For any meta-programming we suggest using <a href="https://winvector.github.io/wrapr/reference/let.html"><code><a href="http://www.rdocumentation.org/packages/wrapr/topics/let">wrapr::let()</a></code></a>, a powerful and <a href="https://github.com/WinVector/wrapr/blob/master/extras/wrapr_let.pdf">well-documented</a> meta-programming system.</p>
</div>
<div id="assignment-partitioning" class="section level1">
<h1 class="hasAnchor">
<a href="#assignment-partitioning" class="anchor"></a>Assignment partitioning</h1>
<p><code>rquery</code> accepts many assignment in a <code><a href="../reference/sql_node.html">sql_node()</a></code> or in a single <code>extend</code> node. The <code>extend</code> node comes with automatic <a href="#assignment-partitioning">assignment partitioning</a> to ensure correct and performant results. This allows the user to write large <code>extend</code> blocks and know they will be executed correctly.</p>
<p>Here is an example.</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb56-1" data-line-number="1">ot &lt;-<span class="st"> </span><span class="kw"><a href="../reference/table_source.html">table_source</a></span>(<span class="st">'d4'</span>,</a>
<a class="sourceLine" id="cb56-2" data-line-number="2">                   <span class="dt">columns =</span> <span class="kw">qc</span>(<span class="st">'a'</span>, <span class="st">'b'</span>, <span class="st">'c'</span>, <span class="st">'d'</span>)) <span class="op">%.&gt;%</span></a>
<a class="sourceLine" id="cb56-3" data-line-number="3"><span class="st">  </span><span class="kw"><a href="../reference/extend_nse.html">extend_nse</a></span>(., </a>
<a class="sourceLine" id="cb56-4" data-line-number="4">             <span class="dt">x =</span> a <span class="op">+</span><span class="st"> </span><span class="dv">1</span>,</a>
<a class="sourceLine" id="cb56-5" data-line-number="5">             <span class="dt">y =</span> x <span class="op">+</span><span class="st"> </span><span class="dv">1</span>,</a>
<a class="sourceLine" id="cb56-6" data-line-number="6">             <span class="dt">u =</span> b <span class="op">+</span><span class="st"> </span><span class="dv">1</span>,</a>
<a class="sourceLine" id="cb56-7" data-line-number="7">             <span class="dt">v =</span> c <span class="op">+</span><span class="st"> </span><span class="dv">1</span>,</a>
<a class="sourceLine" id="cb56-8" data-line-number="8">             <span class="dt">w =</span> d <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb56-9" data-line-number="9"></a>
<a class="sourceLine" id="cb56-10" data-line-number="10"><span class="kw">cat</span>(<span class="kw">format</span>(ot))</a></code></pre></div>
<pre><code>## table('d4') %.&gt;%
##  extend(.,
##   x := a + 1,
##   u := b + 1,
##   v := c + 1,
##   w := d + 1) %.&gt;%
##  extend(.,
##   y := x + 1)</code></pre>
<p>Notice the dependent assignment was moved into its own extend block.</p>
<p>A node that uses the assignment partitioning and re-ordering is the <a href="https://winvector.github.io/rquery/reference/if_else_block.html"><code><a href="../reference/if_else_block.html">if_else_block()</a></code></a> which can be used to simulate block-oriented if-else semantics as seen in systems such as <code>SAS</code> (also meaning <code>rquery</code> can be critical porting code from <code>SAS</code> to <code>SQL</code> based <code>R</code>). This allows coordinated assignments such as the following:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb58-1" data-line-number="1">ifet &lt;-<span class="st"> </span><span class="kw"><a href="../reference/table_source.html">table_source</a></span>(<span class="st">"d5"</span>,</a>
<a class="sourceLine" id="cb58-2" data-line-number="2">                     <span class="dt">columns =</span> <span class="kw">qc</span>(test, x, y)) <span class="op">%.&gt;%</span></a>
<a class="sourceLine" id="cb58-3" data-line-number="3"><span class="st">  </span><span class="kw"><a href="../reference/extend_se.html">extend_se</a></span>(.,</a>
<a class="sourceLine" id="cb58-4" data-line-number="4">            <span class="kw"><a href="../reference/if_else_block.html">if_else_block</a></span>(<span class="kw">qe</span>(test <span class="op">&gt;</span><span class="st"> </span><span class="dv">5</span>),</a>
<a class="sourceLine" id="cb58-5" data-line-number="5">                          <span class="dt">thenexprs =</span> <span class="kw">qae</span>(<span class="dt">x =</span> <span class="st">'a'</span>, </a>
<a class="sourceLine" id="cb58-6" data-line-number="6">                                          <span class="dt">y =</span> <span class="st">'b'</span>),</a>
<a class="sourceLine" id="cb58-7" data-line-number="7">                          <span class="dt">elseexprs =</span> <span class="kw">qae</span>(<span class="dt">x =</span> <span class="st">'b'</span>, </a>
<a class="sourceLine" id="cb58-8" data-line-number="8">                                          <span class="dt">y =</span> <span class="st">'a'</span>)</a>
<a class="sourceLine" id="cb58-9" data-line-number="9">            ))</a>
<a class="sourceLine" id="cb58-10" data-line-number="10"><span class="kw">cat</span>(<span class="kw">format</span>(ifet))</a></code></pre></div>
<pre><code>## table('d5') %.&gt;%
##  extend(.,
##   ifebtest_1 := test &gt; 5) %.&gt;%
##  extend(.,
##   x := ifelse(ifebtest_1, "a", x),
##   y := ifelse(ifebtest_1, "b", y)) %.&gt;%
##  extend(.,
##   x := ifelse(!( ifebtest_1 ), "b", x),
##   y := ifelse(!( ifebtest_1 ), "a", y))</code></pre>
<p>As you can see, the <code><a href="../reference/if_else_block.html">if_else_block()</a></code> works by landing the test in a column and then using that column to conditional all further statements. <a href="https://winvector.github.io/wrapr/reference/qe.html"><code>qe()</code></a> and <a href="https://winvector.github.io/wrapr/reference/qae.html"><code>qae()</code></a> are quoting convenience functions. Note the <code>if_else_block</code> depends on <code>x</code> and <code>y</code> being defined before entering the block, as they are self-assigned ( this is checked by the <code>extend</code> node). The <code><a href="../reference/if_else_block.html">if_else_block()</a></code> returns a list of assignments, which then used in the <code><a href="../reference/extend_se.html">extend_se()</a></code> statement, which in turn is re-factored into a sequence of safe extend nodes.</p>
</div>
<div id="performance" class="section level1">
<h1 class="hasAnchor">
<a href="#performance" class="anchor"></a>Performance</h1>
<p>As <code>rquery</code> pipelines are factored into stages similar to the common relational operators they tend to be very compatible with downstream query optimizers. We think some of the advantage is the fact that <code>rquery</code> deliberately does not have a <code>group_by</code> operator, but instead considers this as the <code>partitionby</code> attribute of a <a href="https://winvector.github.io/rquery/reference/project_nse.html"><code>project()</code> node</a> (non-trivial example <a href="https://github.com/WinVector/rquery/blob/master/README.md">here</a>).</p>
<p>We have seen database based <code>rquery</code> outperform both in-memory <code>dplyr</code> and database based <code>dplyr</code> (article <a href="http://www.win-vector.com/blog/2018/01/rquery-fast-data-manipulation-in-r/">here</a>).</p>
<p>In addition <code>rquery</code> includes automatic column narrowing: where only columns used to construct the final result are pulled from initial tables. This feature has show significant additional performance advantages (article <a href="http://www.win-vector.com/blog/2017/12/how-to-greatly-speed-up-your-spark-queries/">here</a>).</p>
</div>
<div id="conclusion" class="section level1">
<h1 class="hasAnchor">
<a href="#conclusion" class="anchor"></a>Conclusion</h1>
<p><code>rquery</code> is new package, but it is already proving to be correct (avoiding <a href="http://www.win-vector.com/blog/2018/01/advisory-on-multiple-assignment-dplyrmutate-on-databases/">known data processing issues</a>) and <a href="http://www.win-vector.com/blog/2018/01/advisory-on-multiple-assignment-dplyrmutate-on-databases/">performant</a>. For working with <code>R</code> at a big data scale (say using <code>PostgreSQL</code> or <code>Spark</code>) <code>rquery</code> is the right specialized tool for specifying data manipulation.</p>
<hr>
</div>
<div id="appendix-always-clean-up-on-the-way-out" class="section level1">
<h1 class="hasAnchor">
<a href="#appendix-always-clean-up-on-the-way-out" class="anchor"></a>Appendix: Always clean up on the way out</h1>
<div class="sourceCode" id="cb60"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb60-1" data-line-number="1"><span class="kw">rm</span>(<span class="dt">list =</span> <span class="st">"winvector_temp_db_handle"</span>)</a>
<a class="sourceLine" id="cb60-2" data-line-number="2">DBI<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/DBI/topics/dbDisconnect">dbDisconnect</a></span>(db)</a></code></pre></div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#introduction">Introduction</a></li>
      <li>
<a href="#pipeable-sql">Pipeable <code>SQL</code></a><ul class="nav nav-pills nav-stacked">
<li><a href="#sql_node"><code><a href="--/reference/sql_node-html">sql_node()</a></code></a></li>
      </ul>
</li>
      <li><a href="#sql-first"><code>SQL</code> first</a></li>
      <li><a href="#ad-hoc-mode">Ad-hoc mode</a></li>
      <li><a href="#table-descriptions">Table descriptions</a></li>
      <li><a href="#operators">Operators</a></li>
      <li><a href="#non-sql-nodes">Non-<code>SQL</code> nodes</a></li>
      <li><a href="#standard-interfaces">Standard interfaces</a></li>
      <li><a href="#assignment-partitioning">Assignment partitioning</a></li>
      <li><a href="#performance">Performance</a></li>
      <li><a href="#conclusion">Conclusion</a></li>
      <li><a href="#appendix-always-clean-up-on-the-way-out">Appendix: Always clean up on the way out</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by John Mount.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://hadley.github.io/pkgdown/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  </body>
</html>
