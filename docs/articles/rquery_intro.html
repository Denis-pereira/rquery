<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>rquery Introduction • rquery</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script><script src="../pkgdown.js"></script><!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-vignette">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">rquery</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/AssigmentPartitioner.html">Assignment Paritioner</a>
    </li>
    <li>
      <a href="../articles/QueryGeneration.html">Query Generation</a>
    </li>
    <li>
      <a href="../articles/rquery_intro.html">rquery Introduction</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">News</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="http://www.win-vector.com/">Sponsor: Win-Vector LLC</a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9">
    <div class="page-header toc-ignore">
      <h1>rquery Introduction</h1>
                        <h4 class="author">John Mount, Win-Vector LLC</h4>
            
            <h4 class="date">2018-03-09</h4>
          </div>

    
    
<div class="contents">
<div id="introduction" class="section level1">
<h1 class="hasAnchor">
<a href="#introduction" class="anchor"></a>Introduction</h1>
<p><a href="https://github.com/WinVector/rquery"><code>rquery</code></a> is a <a href="https://en.wikipedia.org/wiki/SQL"><code>SQL</code></a> query generator for <a href="https://www.r-project.org"><code>R</code></a>. It is based on <a href="https://en.wikipedia.org/wiki/Relational_algebra">Edgar F. Codd’s relational algebra</a> plus experience using <code>SQL</code> and <a href="https://CRAN.R-project.org/package=dplyr"><code>dplyr</code></a> at big data scale. The design represents an attempt to make <code>SQL</code> more teachable by denoting composition a sequential pipeline notation instead of nested queries or functions. The implementation delivers reliable high performance data processing on large data systems such as <code>Spark</code> and databases. Package features include: data processing trees or pipelines as observable objects (able to report both columns produced and columns used), optimized <code>SQL</code> generation as an explicit user visible modeling step, and convenience methods for applying query trees to in-memory <code>data.frame</code>s.</p>
</div>
<div id="pipeable-sql" class="section level1">
<h1 class="hasAnchor">
<a href="#pipeable-sql" class="anchor"></a>Pipeable <code>SQL</code>
</h1>
<p><code>SQL</code> is a very powerful data processing (or data engineering) grammar. Data scientists are well advised to learn to work with <code>SQL</code>.</p>
<p>An inessential difficulty of using <code>SQL</code> is <code>SQL</code> represents composition of operations by nesting, which can rapidly become confusing and illegible.</p>
<p>Let’s set up our environment so we can work with examples.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">"rquery"</span>)</code></pre></div>
<pre><code>## Loading required package: wrapr</code></pre>
<pre><code>## Loading required package: DBI</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># example database connection</span>
db &lt;-<span class="st"> </span>DBI<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/DBI/topics/dbConnect">dbConnect</a></span>(RSQLite<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/RSQLite/topics/SQLite">SQLite</a></span>(),
                     <span class="st">":memory:"</span>)
RSQLite<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/RSQLite/topics/initExtension">initExtension</a></span>(db)

<span class="co"># example data</span>
d &lt;-<span class="st"> </span><span class="kw"><a href="../reference/dbi_copy_to.html">dbi_copy_to</a></span>(
  db, <span class="st">'d'</span>,
  <span class="kw">data.frame</span>(<span class="dt">v =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="op">-</span><span class="dv">5</span>, <span class="dv">3</span>)),
  <span class="dt">temporary =</span> <span class="ot">FALSE</span>,
  <span class="dt">overwrite =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p><code>d</code> is what we call a “table description” which is just the name of a table and the names of expected columns. <code>d</code> does not store data or a database reference (making it safe to serialize/de-serialize). All <code>rquery</code> operation trees or pipelines must start either with a table description or a <code>data.frame</code>. We will discuss table descriptions later.</p>
<p>For our first example we will introduce a new column and perform a calculation using this column. This is achieved in <code>SQL</code> by writing code in one of two styles: defining the first new column twice (once to land the value and once to use), or sequencing two queries by nesting. We will demonstrate both methods.</p>
<p>The define the column twice solution looks like the following.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DBI<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/DBI/topics/dbGetQuery">dbGetQuery</a></span>(db, <span class="st">"</span>
<span class="st">  SELECT</span>
<span class="st">    *,</span>
<span class="st">    ABS(v) AS absv,</span>
<span class="st">    ABS(v) - v AS delta</span>
<span class="st">  FROM</span>
<span class="st">    d</span>
<span class="st">"</span>)</code></pre></div>
<pre><code>##    v absv delta
## 1  1    1     0
## 2 -5    5    10
## 3  3    3     0</code></pre>
<p>In <code>SQL</code> the column <code>absv</code> is not available for calculation in the same query that it is produced.</p>
<p>The nested method looks like the following, we produce the column <code>absv</code> in one query and then wrap that in another query to later use the column. For expressions longer than <code>ABS(v)</code> this is the preferred solution.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DBI<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/DBI/topics/dbGetQuery">dbGetQuery</a></span>(db, <span class="st">"</span>
<span class="st">  SELECT</span>
<span class="st">    *,</span>
<span class="st">    absv - v AS delta</span>
<span class="st">  FROM (</span>
<span class="st">    SELECT</span>
<span class="st">      *,</span>
<span class="st">      ABS(v) AS absv</span>
<span class="st">    FROM</span>
<span class="st">      d</span>
<span class="st">  ) subtab</span>
<span class="st">"</span>)</code></pre></div>
<pre><code>##    v absv delta
## 1  1    1     0
## 2 -5    5    10
## 3  3    3     0</code></pre>
<div id="sql_node" class="section level2">
<h2 class="hasAnchor">
<a href="#sql_node" class="anchor"></a><code><a href="../reference/sql_node.html">sql_node()</a></code>
</h2>
<p>Using <code>rquery</code> we can write the <code>SQL</code> composition using pipe notation (where composition is written as <code>x %.&gt;% f %.&gt;% g</code> instead of <code>g(f(x))</code>). We are going to user <a href="https://github.com/WinVector/wrapr"><code>wrapr</code></a> <a href="https://winvector.github.io/wrapr/reference/grapes-.-greater-than-grapes.html">dot-pipe</a> instead of the <a href="https://CRAN.R-project.org/package=magrittr"><code>magrittr</code></a> pipe to pick up a neat feature we will use later (with the exception of that feature all examples will work with the <code>magrittr</code> pipe).</p>
<p>The <code>rquery</code> realization of the above calculation is as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">op_tree &lt;-<span class="st"> </span>d <span class="op">%.&gt;%</span>
<span class="st">  </span><span class="kw"><a href="../reference/sql_node.html">sql_node</a></span>(., <span class="st">"absv"</span> <span class="op">:</span><span class="er">=</span><span class="st"> "ABS(v)"</span>) <span class="op">%.&gt;%</span>
<span class="st">  </span><span class="kw"><a href="../reference/sql_node.html">sql_node</a></span>(., <span class="st">"delta"</span> <span class="op">:</span><span class="er">=</span><span class="st"> "absv - v"</span>)
<span class="kw"><a href="../reference/execute.html">execute</a></span>(db, op_tree)</code></pre></div>
<pre><code>##    v absv delta
## 1  1    1     0
## 2 -5    5    10
## 3  3    3     0</code></pre>
<p>The above is what we call “piped <code>SQL</code>” and represents a major convenience for users as the details of how to compose the statements are left to the package.</p>
<p>We can get the <code>SQL</code> equivalent to the operations tree as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cat</span>(<span class="kw"><a href="../reference/to_sql.html">to_sql</a></span>(op_tree, db))</code></pre></div>
<pre><code>SELECT
 *,
 absv - v AS `delta`
FROM (
 SELECT
  *,
  ABS(v) AS `absv`
 FROM (
  SELECT
   `d`.`v`
  FROM
   `d`
 ) tsql_77730293286227562298_0000000000
) tsql_77730293286227562298_0000000001</code></pre>
<p>Notice the above expressions did not add identifier quotes to our use of “<code>v</code>” in “<code>ABS(v)</code>”. This is because the <code>SQL</code> expression is not parsed in <code>R</code>. If we want to identify terms as variables we can wrap them with <code>as.name()</code> or <code>quote()</code> to get the quoting (and other variable oriented features). The extra <code>SELECT</code> step to pull data from the inner table is used by <code>rquery</code> for important column narrowing steps, and can actually improve query performance.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">op_tree &lt;-<span class="st"> </span>d <span class="op">%.&gt;%</span>
<span class="st">  </span><span class="kw"><a href="../reference/sql_node.html">sql_node</a></span>(., <span class="st">"absv"</span> <span class="op">:</span><span class="er">=</span><span class="st"> </span><span class="kw">list</span>(<span class="kw">list</span>(<span class="st">"ABS("</span>, <span class="kw">quote</span>(v), <span class="st">")"</span>))) <span class="op">%.&gt;%</span>
<span class="st">  </span><span class="kw"><a href="../reference/sql_node.html">sql_node</a></span>(., <span class="st">"delta"</span> <span class="op">:</span><span class="er">=</span><span class="st"> </span><span class="kw">list</span>(<span class="kw">list</span>(<span class="kw">quote</span>(absv),<span class="st">"-"</span>, <span class="kw">quote</span>(v))))
<span class="kw">cat</span>(<span class="kw"><a href="../reference/to_sql.html">to_sql</a></span>(op_tree, db))</code></pre></div>
<pre><code>SELECT
 *,
 `absv` - `v` AS `delta`
FROM (
 SELECT
  *,
  ABS( `v` ) AS `absv`
 FROM (
  SELECT
   `d`.`v`
  FROM
   `d`
 ) tsql_64589670367954382879_0000000000
) tsql_64589670367954382879_0000000001</code></pre>
<p>The <code>list(list())</code> notation is how we say in <code>R</code> that we have a single element list (i.e. one expression) that is built up as a list of terms.</p>
<p><code>op_tree</code> is a an object with its own presentation format:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(op_tree)</code></pre></div>
<pre><code>## [1] "table('d') %.&gt;% sql_node(., absv := ABS( v ), *=TRUE) %.&gt;% sql_node(., delta := absv - v, *=TRUE)"</code></pre>
<p>And <code>op_tree</code> stores an number of important summaries about the proposed query:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/column_names.html">column_names</a></span>(op_tree)</code></pre></div>
<pre><code>## [1] "delta" "absv"  "v"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/tables_used.html">tables_used</a></span>(op_tree)</code></pre></div>
<pre><code>## [1] "d"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/columns_used.html">columns_used</a></span>(op_tree)</code></pre></div>
<pre><code>## $d
## [1] "v"</code></pre>
<div id="composing-nodes" class="section level3">
<h3 class="hasAnchor">
<a href="#composing-nodes" class="anchor"></a>Composing nodes</h3>
<p>We can add nodes to an <code>op_tree</code> to build larger operator trees (or pipelines).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">op_tree &lt;-<span class="st"> </span>op_tree <span class="op">%.&gt;%</span>
<span class="st">  </span><span class="kw"><a href="../reference/sql_node.html">sql_node</a></span>(., <span class="st">"prod"</span> <span class="op">:</span><span class="er">=</span><span class="st"> "absv * delta"</span>)

<span class="kw">cat</span>(<span class="kw">format</span>(op_tree))</code></pre></div>
<pre><code>## table('d') %.&gt;%
##  sql_node(.,
##           absv := ABS( v ),
##              *=TRUE) %.&gt;%
##  sql_node(.,
##           delta := absv - v,
##              *=TRUE) %.&gt;%
##  sql_node(.,
##           prod := absv * delta,
##              *=TRUE)</code></pre>
<p>And, the <code>op_tree</code> record keeping can be used to catch potential errors early in pipeline construction. For example if we try to refer to a non-existent variable when adding an operator we get an thrown exception (note the node being added must have its variables marked as above for pre-checking to occur).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">op_tree &lt;-<span class="st"> </span>op_tree <span class="op">%.&gt;%</span>
<span class="st">  </span><span class="kw"><a href="../reference/sql_node.html">sql_node</a></span>(., <span class="st">"z"</span> <span class="op">:</span><span class="er">=</span><span class="st"> </span><span class="kw">list</span>(<span class="kw">list</span>(<span class="st">"1 + "</span>, <span class="kw">quote</span>(z))))</code></pre></div>
<pre><code>## Error in sql_node.relop(., `:=`("z", list(list("1 + ", quote(z))))): rquery::sql_node.relop undefined columns: z</code></pre>
</div>
</div>
</div>
<div id="sql-first" class="section level1">
<h1 class="hasAnchor">
<a href="#sql-first" class="anchor"></a><code>SQL</code> first</h1>
<p><code>rquery</code> is a “<code>SQL</code> first” system. It is designed only to create <code>SQL</code> queries and dispatch them to remote systems (<code>SQLite</code>, <code>Spark</code>, <code>PostgreSQL</code>, <code>Redshift</code>, and other databases) for execution. The <a href="https://winvector.github.io/rquery/reference/execute.html"><code><a href="../reference/execute.html">execute()</a></code></a> method can be used with big data by adding a <code>table_name</code> argument (or also by using the <a href="https://winvector.github.io/rquery/reference/materialize.html"><code><a href="../reference/materialize.html">materialize()</a></code></a> method) to land results in a remote table instead of pulling them back to <code>R</code>.</p>
<p>The better the database implementation the better <code>rquery</code> will be, both in terms of performance and in terms of function (such as the availability of <code>SQL</code> window functions).</p>
</div>
<div id="ad-hoc-mode" class="section level1">
<h1 class="hasAnchor">
<a href="#ad-hoc-mode" class="anchor"></a>Ad-hoc mode</h1>
<p>As a convenience <code>rquery</code> can work with in-memory <code>data.frame</code>s by sending them to the <code>SQL</code> service provider. This provider defaults to <code>RSQlite</code> or can be set by setting the global variable <code>winvector_temp_db_handle</code>. We demonstrate this below.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">winvector_temp_db_handle &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">db =</span> db)

<span class="kw">data.frame</span>(<span class="dt">v =</span> <span class="op">-</span><span class="dv">2</span><span class="op">:</span><span class="dv">2</span>) <span class="op">%.&gt;%</span>
<span class="st">  </span><span class="kw"><a href="../reference/execute.html">execute</a></span>(., op_tree)</code></pre></div>
<pre><code>##    v absv delta prod
## 1 -2    2     4    8
## 2 -1    1     2    2
## 3  0    0     0    0
## 4  1    1     0    0
## 5  2    2     0    0</code></pre>
<p>When using the <code>wrapr</code> dot pipe the above can be abbreviated as:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data.frame</span>(<span class="dt">v =</span> <span class="op">-</span><span class="dv">2</span><span class="op">:</span><span class="dv">2</span>) <span class="op">%.&gt;%</span><span class="st"> </span>op_tree</code></pre></div>
<pre><code>##    v absv delta prod
## 1 -2    2     4    8
## 2 -1    1     2    2
## 3  0    0     0    0
## 4  1    1     0    0
## 5  2    2     0    0</code></pre>
<p>(Note: the above calculation is triggered by <code>wrapr</code> dot pipe <code>S3</code> <code>wrapr_function</code> definitions.)</p>
<p>Also <code>rquery</code> operators can be used directly (without any table description nodes) when working with in-memory <code>data.frame</code>s.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">5</span>) <span class="op">%.&gt;%</span><span class="st"> </span><span class="kw"><a href="../reference/sql_node.html">sql_node</a></span>(., <span class="st">"z"</span> <span class="op">:</span><span class="er">=</span><span class="st"> "sqrt(x)"</span>)</code></pre></div>
<pre><code>##   x        z
## 1 5 2.236068</code></pre>
<p>(Note: the above calculation is triggered by <code>S3</code> override of any of <code>print()</code>, <code>as.data.frame()</code> and <code>head()</code>).</p>
</div>
<div id="table-descriptions" class="section level1">
<h1 class="hasAnchor">
<a href="#table-descriptions" class="anchor"></a>Table descriptions</h1>
<p><code>rquery</code> table descriptions are simple objects that store only the name of a table and expected columns. Any local data or database table that has at least the set of columns named in the table description can be used in a given <code>rquery</code> pipeline.</p>
<p>The table description “<code>d</code>” we have been using in examples was produced as a result of moving data to a database by <a href="https://winvector.github.io/rquery/reference/dbi_copy_to.html"><code><a href="../reference/dbi_copy_to.html">dbi_copy_to()</a></code></a>. However we can also create a description of an existing table with <a href="https://winvector.github.io/rquery/reference/dbi_table.html"><code><a href="../reference/dbi_table.html">dbi_table()</a></code></a> or even build a description by hand with <a href="https://winvector.github.io/rquery/reference/table_source.html"><code><a href="../reference/table_source.html">table_source()</a></code></a>.</p>
</div>
<div id="operators" class="section level1">
<h1 class="hasAnchor">
<a href="#operators" class="anchor"></a>Operators</h1>
<p>The <a href="https://winvector.github.io/rquery/reference/sql_node.html"><code><a href="../reference/sql_node.html">sql_node()</a></code></a> alone can make writing, understanding, and maintaining complex data transformations as queries much easier. And this node is a good introduction to some of the power of the <code>rquery</code> package. However, the primary purpose of <code>rquery</code> is to provide ready-made relational operators to further simplify to the point of rarely needing to use the <code><a href="../reference/sql_node.html">sql_node()</a></code> directly.</p>
<p>The primary operators supplied by <code>rquery</code> are:</p>
<p>The primary relational operators include:</p>
<ul>
<li>
<a href="https://winvector.github.io/rquery/reference/extend_nse.html"><code><a href="../reference/extend_nse.html">extend_nse()</a></code></a>/<a href="https://winvector.github.io/rquery/reference/extend_se.html"><code><a href="../reference/extend_se.html">extend_se()</a></code></a>. Extend adds derived columns to a relation table. With a sufficiently powerful <code>SQL</code> provider this includes ordered and partitioned window functions. This operator also includes built-in <a href="https://winvector.github.io/seplyr/"><code>seplyr</code></a>-style <a href="https://winvector.github.io/seplyr/articles/MutatePartitioner.html">assignment partitioning</a>.</li>
<li>
<a href="https://winvector.github.io/rquery/reference/project_nse.html"><code>project()</code></a>. Project is usually <em>portrayed</em> as the equivalent to column selection, though the original definition includes aggregation. In our opinion the original relational nature of the operator is best captured by moving <code>SQL</code>’s “<code>GROUP BY</code>” aggregation functionality.</li>
<li>
<a href="https://winvector.github.io/rquery/reference/natural_join.html"><code><a href="../reference/natural_join.html">natural_join()</a></code></a>. This a specialized relational join operator, using all common columns as an equi-join condition.</li>
<li>
<a href="https://winvector.github.io/rquery/reference/theta_join_nse.html"><code>theta_join()</code></a>. This is the relational join operator allowing an arbitrary matching predicate.</li>
<li>
<a href="https://winvector.github.io/rquery/reference/theta_join_nse.html"><code>select_rows()</code></a>. This is Codd’s relational row selection. Obviously <code>select</code> alone is an over-used and now ambiguous term (for example: it is already used as the “doit” verb in <code>SQL</code> and the <em>column</em> selector in <code>dplyr</code>).</li>
<li>
<a href="https://winvector.github.io/rquery/reference/rename_columns.html"><code><a href="../reference/rename_columns.html">rename_columns()</a></code></a>. This operator renames sets of columns.</li>
</ul>
<p>The primary non-relational (traditional <code>SQL</code>) operators are:</p>
<ul>
<li>
<a href="https://winvector.github.io/rquery/reference/select_columns.html"><code><a href="../reference/select_columns.html">select_columns()</a></code></a>. This allows choice of columns (central to <code>SQL</code>), but is not a relational operator as it can damage row-uniqueness.</li>
<li>
<a href="https://winvector.github.io/rquery/reference/orderby.html"><code><a href="../reference/orderby.html">orderby()</a></code></a>. Row order is not a concept in the relational algebra (and also not maintained in most <code>SQL</code> implementations). This operator is only useful when used with its <code>limit=</code> option, or as the last step as data comes out of the relation store and is moved to <code>R</code> (where row-order is usually maintained).</li>
</ul>
<p>The above list (and especially naming) are chosen to first match Codd’s relational concepts (<code>project</code>, <code>select</code>, <code>rename</code>, <code>join</code>, aggregation), <code>SQL</code> naming conventions. Notice this covers the <a href="http://dplyr.tidyverse.org">primary <code>dplyr</code> operators</a> <code>mutate()</code> (Codd’s <code>extend</code>), <code>select()</code> (not relational), <code>filter()</code> (Codd’s <code>select</code>, represented in <code>SQL</code> by “<code>WHERE</code>”), <code>summarise()</code> (Codd’s <code>project</code> or aggregate concepts, triggered in <code>SQL</code> by “<code>GROUP BY</code>”), <code>arrange()</code> (not a relational concept, implemented in <code>SQL</code> by “ORDER BY”). This correspondence is due to Codd’s ideas and <code>SQL</code> driving data engineering thinking for almost the last 50 years (both with and without credit or citation).</p>
<p>With relational operators the user can work fast and work further away from syntactic details. For example with a database that supplies window functions one can quickly work the “logistic scoring by hand” from<br>
from <a href="http://www.win-vector.com/blog/2017/08/lets-have-some-sympathy-for-the-part-time-r-user/">Let’s Have Some Sympathy For The Part-time R User</a>. That example worked with <code>rquery</code> code that works with both <code>PostgreSQL</code> and <code>Spark</code> can be found <a href="https://github.com/WinVector/rquery/blob/master/README.md">here</a>.</p>
</div>
<div id="non-sql-node" class="section level1">
<h1 class="hasAnchor">
<a href="#non-sql-node" class="anchor"></a>Non-<code>SQL</code> node</h1>
<p>Not all data transform steps can conveniently be written as a single <code>SQL</code> statement. To work around this potential limitation <code>rquery</code> supplies a special type of node called</p>
</div>
<div id="statement-partitioning" class="section level1">
<h1 class="hasAnchor">
<a href="#statement-partitioning" class="anchor"></a>Statement partitioning</h1>
</div>
<div id="ifelse-device" class="section level1">
<h1 class="hasAnchor">
<a href="#ifelse-device" class="anchor"></a>ifelse device</h1>
</div>
<div id="correctness" class="section level1">
<h1 class="hasAnchor">
<a href="#correctness" class="anchor"></a>correctness</h1>
</div>
<div id="performance" class="section level1">
<h1 class="hasAnchor">
<a href="#performance" class="anchor"></a>performance</h1>
<div id="comparisons" class="section level2">
<h2 class="hasAnchor">
<a href="#comparisons" class="anchor"></a>Comparisons</h2>
</div>
<div id="column-narrowing" class="section level2">
<h2 class="hasAnchor">
<a href="#column-narrowing" class="anchor"></a>Column narrowing</h2>
</div>
</div>
<div id="appendix-always-clean-up-on-the-way-out" class="section level1">
<h1 class="hasAnchor">
<a href="#appendix-always-clean-up-on-the-way-out" class="anchor"></a>Appendix: Always clean up on the way out</h1>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">rm</span>(<span class="dt">list =</span> <span class="st">"winvector_temp_db_handle"</span>)
DBI<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/DBI/topics/dbDisconnect">dbDisconnect</a></span>(db)</code></pre></div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#introduction">Introduction</a></li>
      <li>
<a href="#pipeable-sql">Pipeable <code>SQL</code></a><ul class="nav nav-pills nav-stacked">
<li><a href="#sql_node"><code><a href="--/reference/sql_node-html">sql_node()</a></code></a></li>
      </ul>
</li>
      <li><a href="#sql-first"><code>SQL</code> first</a></li>
      <li><a href="#ad-hoc-mode">Ad-hoc mode</a></li>
      <li><a href="#table-descriptions">Table descriptions</a></li>
      <li><a href="#operators">Operators</a></li>
      <li><a href="#non-sql-node">Non-<code>SQL</code> node</a></li>
      <li><a href="#statement-partitioning">Statement partitioning</a></li>
      <li><a href="#ifelse-device">ifelse device</a></li>
      <li><a href="#correctness">correctness</a></li>
      <li>
<a href="#performance">performance</a><ul class="nav nav-pills nav-stacked">
<li><a href="#comparisons">Comparisons</a></li>
      <li><a href="#column-narrowing">Column narrowing</a></li>
      </ul>
</li>
      <li><a href="#appendix-always-clean-up-on-the-way-out">Appendix: Always clean up on the way out</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by John Mount.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://hadley.github.io/pkgdown/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  </body>
</html>
