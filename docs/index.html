<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Relational Query Algebra for Data Manipulation • rquery</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- pkgdown --><link href="pkgdown.css" rel="stylesheet">
<script src="jquery.sticky-kit.min.js"></script><script src="pkgdown.js"></script><!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-vignette">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">rquery</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="reference/index.html">Reference</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9">
    

    
    
<div class="contents">
<!-- README.md is generated from README.Rmd. Please edit that file -->
<p><code>rquery</code> is a experimental/demonstration of a simplified sequenced query language based on <a href="https://en.wikipedia.org/wiki/Relational_algebra">Codd’s relational algebra</a> and not currently recommended for non-experimental use. <code>rquery</code> is something we whipped up in a singe weekend to see how small a scope such an adapter might have.</p>
<p>A few things <code>rquery</code> is missing include:</p>
<ul>
<li>
<code>rquery</code> does not have the table lifetime management tools.</li>
<li>Substitution of values from the environment into expressions.</li>
<li>Quoting of column names within complex expressions.</li>
</ul>
<p>All of the above are easy to add, but not central to the one-off experiment. <code>rquery</code> is not for production use, but can be an excellent advanced <code>SQL</code> training tool (it shows how some very deep <code>SQL</code> by composing <code>rquery</code> operators). Right now <code>rquery</code> is biased towards <code>PostgeSQL</code> <code>SQL</code>.</p>
<p>There are many other relational algebra inspired specialized query languages.</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Alpha_(programming_language)">Alpha</a></li>
<li><a href="https://en.wikipedia.org/wiki/QUEL_query_languages">QUEL</a></li>
<li><a href="https://en.wikipedia.org/wiki/D_(data_language_specification)#Tutorial_D">Tutorial D</a></li>
<li><a href="https://msdn.microsoft.com/en-us/library/bb308959.aspx">LINQ</a></li>
<li><a href="https://en.wikipedia.org/wiki/SQL">SQL</a></li>
<li>(and possibly) <a href="http://dplyr.tidyverse.org"><code>dplyr</code></a>
</li>
</ul>
<p><code>rquery</code> is a thin translation to <code>SQL</code> layer, but we are trying to put the Codd relational operators front and center (user their naming, and back-port <code>SQL</code> progress such as window functions to the appropriate relational operator). <code>rquery</code> differs from <code>dplyr</code> in that <code>rquery</code> is trying to stay near the Codd relational operators (in particular grouping is a transient state inside the <code>rquery::extend()</code> operator, not a durable user visible annotation as with <code><a href="http://dplyr.tidyverse.org/reference/group_by.html">dplyr::group_by()</a></code>).</p>
<p>The primary relational operators are:</p>
<ul>
<li>
<code>extend()</code>. Extend adds derived columns to a relation table. With a sufficiently powerful <code>SQL</code> provider this includes ordered and partitioned window functions.</li>
<li>
<code>project()</code>. Project is usually portrait as the equivalent to column selection. In our opinion the original relational nature of the operator is best captured by moving <code>SQL</code>’s “<code>GROUP BY</code>” aggregation functionality to this operator.</li>
<li>
<code><a href="reference/natural_join.html">natural_join()</a></code>. This is the relational join operator, using all common columns as the equi-join condition. The next operator to add would definitely be <code>theta-join</code> as that adds a lot more expressiveness to the grammar.</li>
<li>
<code>select_rows()</code>. This is Codd’s relational row selection. Obviously <code>select</code> alone is an over-used and now ambiguous term (it is the “doit” verb in <code>SQL</code> and the <em>column</em> selector in <code>dplyr</code>).</li>
</ul>
<p>The primary non-relational (traditional <code>SQL</code>) operators are:</p>
<ul>
<li>
<code><a href="reference/select_columns.html">select_columns()</a></code>. This allows choice of columns (central to <code>SQL</code>), but is not a relational operator as it can damage row-uniqueness.</li>
<li>
<code><a href="reference/order_by.html">order_by()</a></code>. This is a non-relational “user presentation” verb. Row order is not well-defined in the relational algebra (and also not in most <code>SQL</code> implementations). If used it should be used last in a query (so it is not undone by later operations).</li>
</ul>
<p>The primary missing relational operators are:</p>
<ul>
<li>Direct rename.</li>
<li>Union.</li>
<li>Direct set difference, anti-join.</li>
<li>Theta-join.</li>
<li>Division.</li>
</ul>
<p>Primary useful missing operators:</p>
<ul>
<li>Deselect columns.</li>
</ul>
<p>A great benefit of Codd’s relational algebra is it decomposes data transformations into a sequence of operators. <code>SQL</code> loses a lot of the original invariants, and over-specifies how operations are strung together and insisting on a nesting function notation. <code>SQL</code> also realizes some of the Codd concepts as operators, some as expressions, and some as predicates (obscuring the uniformity of the original theory).</p>
<p>A lot of the grace of the Codd theory can be recovered through the usual trick changing function composition notation from <code>g(f(x))</code> as <code>x . f() . g()</code>.</p>
<p>The <code>rquery</code> operators are passive. They don’t do anything other than collect a specification of the desired calculation. This data structure can then be printed in a friendly fashion, used to generate <code>SQL</code>, and (in principle) be the representational layer for a higher-order optimizer.</p>
<p>As an acid test we generate a query equivalent to the non-trivial <code>dplyr</code> pipeline demonstrated in <a href="http://www.win-vector.com/blog/2017/08/lets-have-some-sympathy-for-the-part-time-r-user/">Let’s Have Some Sympathy For The Part-time R User</a>.</p>
<p>First we set up the database and example data:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">"rquery"</span>)</code></pre></div>
<pre><code>## Loading required package: wrapr</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">'RPostgreSQL'</span>)</code></pre></div>
<pre><code>## Loading required package: DBI</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">my_db &lt;-<span class="st"> </span>DBI<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/DBI/topics/dbConnect">dbConnect</a></span>(<span class="kw">dbDriver</span>(<span class="st">"PostgreSQL"</span>), 
                        <span class="dt">host =</span> <span class="st">'localhost'</span>,
                        <span class="dt">port =</span> <span class="dv">5432</span>,
                        <span class="dt">user =</span> <span class="st">'postgres'</span>,
                        <span class="dt">password =</span> <span class="st">'pg'</span>)

d &lt;-<span class="st"> </span><span class="kw"><a href="reference/dbi_copy_to.html">dbi_copy_to</a></span>(my_db, <span class="st">'d'</span>,
                 <span class="kw">data.frame</span>(
                   <span class="dt">subjectID =</span> <span class="kw">c</span>(<span class="dv">1</span>,                   
                                 <span class="dv">1</span>,
                                 <span class="dv">2</span>,                   
                                 <span class="dv">2</span>),
                   <span class="dt">surveyCategory =</span> <span class="kw">c</span>(
                     <span class="st">'withdrawal behavior'</span>,
                     <span class="st">'positive re-framing'</span>,
                     <span class="st">'withdrawal behavior'</span>,
                     <span class="st">'positive re-framing'</span>
                   ),
                   <span class="dt">assessmentTotal =</span> <span class="kw">c</span>(<span class="dv">5</span>,                 
                                       <span class="dv">2</span>,
                                       <span class="dv">3</span>,                  
                                       <span class="dv">4</span>),
                   <span class="dt">stringsAsFactors =</span> <span class="ot">FALSE</span>),
                 <span class="dt">temporary =</span> <span class="ot">TRUE</span>, <span class="dt">overwrite =</span> <span class="ot">TRUE</span>)

<span class="kw">print</span>(d)</code></pre></div>
<pre><code>## [1] "dbi_table('d')"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">d <span class="op">%.&gt;%</span>
<span class="st">  </span><span class="kw"><a href="reference/to_sql.html">to_sql</a></span>(.) <span class="op">%.&gt;%</span>
<span class="st">  </span>DBI<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/DBI/topics/dbGetQuery">dbGetQuery</a></span>(my_db, .) <span class="op">%.&gt;%</span>
<span class="st">  </span>knitr<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/knitr/topics/kable">kable</a></span>(.)</code></pre></div>
<table class="table">
<thead><tr class="header">
<th align="left">row.names</th>
<th align="right">subjectID</th>
<th align="left">surveyCategory</th>
<th align="right">assessmentTotal</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="right">1</td>
<td align="left">withdrawal behavior</td>
<td align="right">5</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="right">1</td>
<td align="left">positive re-framing</td>
<td align="right">2</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="right">2</td>
<td align="left">withdrawal behavior</td>
<td align="right">3</td>
</tr>
<tr class="even">
<td align="left">4</td>
<td align="right">2</td>
<td align="left">positive re-framing</td>
<td align="right">4</td>
</tr>
</tbody>
</table>
<p>Now we write the calculation in terms of our operators (we have not yet bothered to add the expression capture features to all of the <code>rquery</code> operators, so we are currently simulating it using the development version <code>1.0.2</code> of <a href="https://winvector.github.io/wrapr/"><code>wrapr</code></a>; the package itself works with the production release version of <code>wrapr</code>).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">scale &lt;-<span class="st"> </span><span class="fl">0.237</span>

dq &lt;-<span class="st"> </span>d <span class="op">%.&gt;%</span>
<span class="st">  </span><span class="kw"><a href="reference/extend_nse.html">extend_nse</a></span>(.,
             probability <span class="op">:</span><span class="er">=</span>
<span class="st">               </span><span class="kw">exp</span>(assessmentTotal <span class="op">*</span><span class="st"> </span>scale)<span class="op">/</span>
<span class="st">               </span><span class="kw">sum</span>(<span class="kw">exp</span>(assessmentTotal <span class="op">*</span><span class="st"> </span>scale)),
             count <span class="op">:</span><span class="er">=</span><span class="st"> </span><span class="kw">count</span>(<span class="dv">1</span>),
             <span class="dt">partitionby =</span> <span class="st">'subjectID'</span>) <span class="op">%.&gt;%</span>
<span class="st">  </span><span class="kw"><a href="reference/extend_nse.html">extend_nse</a></span>(.,
             rank <span class="op">:</span><span class="er">=</span><span class="st"> </span><span class="kw">rank</span>(),
             <span class="dt">partitionby =</span> <span class="st">'subjectID'</span>,
             <span class="dt">orderby =</span> <span class="st">'probability'</span>)  <span class="op">%.&gt;%</span>
<span class="st">  </span><span class="kw"><a href="reference/extend_nse.html">extend_nse</a></span>(.,
             isdiagnosis <span class="op">:</span><span class="er">=</span><span class="st"> </span>rank <span class="op">&gt;=</span><span class="st"> </span>count,
             diagnosis <span class="op">:</span><span class="er">=</span><span class="st"> </span>surveyCategory) <span class="op">%.&gt;%</span>
<span class="st">  </span><span class="kw"><a href="reference/select_rows_nse.html">select_rows_nse</a></span>(., isdiagnosis) <span class="op">%.&gt;%</span>
<span class="st">  </span><span class="kw"><a href="reference/select_columns.html">select_columns</a></span>(., <span class="kw">c</span>(<span class="st">"subjectID"</span>, 
                      <span class="st">"diagnosis"</span>, 
                       <span class="st">"probability"</span>)) <span class="op">%.&gt;%</span>
<span class="st">  </span><span class="kw"><a href="reference/order_by.html">order_by</a></span>(., <span class="st">'subjectID'</span>)</code></pre></div>
<p>All of the non-standard expression capture (<code><a href="http://www.rdocumentation.org/packages/wrapr/topics/qc">wrapr::qc()</a></code>, <code><a href="http://www.rdocumentation.org/packages/wrapr/topics/qae">wrapr::qae()</a></code>, substituting in the <code>scale</code>, and avoiding the quoted <code>SQL</code> column names) could easily be incorporated into the relation nodes.</p>
<p>We then have our result:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dq <span class="op">%.&gt;%</span>
<span class="st">  </span><span class="kw"><a href="reference/to_sql.html">to_sql</a></span>(.) <span class="op">%.&gt;%</span>
<span class="st">  </span>DBI<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/DBI/topics/dbGetQuery">dbGetQuery</a></span>(my_db, .) <span class="op">%.&gt;%</span>
<span class="st">  </span>knitr<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/knitr/topics/kable">kable</a></span>(.)</code></pre></div>
<table class="table">
<thead><tr class="header">
<th align="right">subjectID</th>
<th align="left">diagnosis</th>
<th align="right">probability</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="right">1</td>
<td align="left">withdrawal behavior</td>
<td align="right">0.6706221</td>
</tr>
<tr class="even">
<td align="right">2</td>
<td align="left">positive re-framing</td>
<td align="right">0.5589742</td>
</tr>
</tbody>
</table>
<p>We see we reproduced the result purely in terms of these database operators.</p>
<p>The actual <code>SQL</code> query that produces the result is quite involved:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cat</span>(<span class="kw"><a href="reference/to_sql.html">to_sql</a></span>(dq))</code></pre></div>
<pre><code>SELECT * FROM (
 SELECT
  "subjectID", "diagnosis", "probability"
 FROM (
  SELECT * FROM (
   SELECT
    "row.names",
    "subjectID",
    "surveyCategory",
    "assessmentTotal",
    "probability",
    "count",
    "rank",
    "rank" &gt;= "count"  AS "isdiagnosis",
    "surveyCategory"  AS "diagnosis"
   FROM (
    SELECT
     "row.names",
     "subjectID",
     "surveyCategory",
     "assessmentTotal",
     "probability",
     "count",
     rank()  OVER (  PARTITION BY "subjectID" ORDER BY "probability" ) AS "rank"
    FROM (
     SELECT
      "row.names",
      "subjectID",
      "surveyCategory",
      "assessmentTotal",
      exp("assessmentTotal" * 0.237) / sum(exp("assessmentTotal" * 0.237))  OVER (  PARTITION BY "subjectID" ) AS "probability",
      count(1)  OVER (  PARTITION BY "subjectID" ) AS "count"
     FROM (
      SELECT * FROM "d"
     ) tsql_d6pv2se0gzp6abrcuz4y_0000000000
    ) tsql_d6pv2se0gzp6abrcuz4y_0000000001
   ) tsql_d6pv2se0gzp6abrcuz4y_0000000002
  ) tsql_d6pv2se0gzp6abrcuz4y_0000000003
  WHERE "isdiagnosis"
 ) tsql_d6pv2se0gzp6abrcuz4y_0000000004
) tsql_d6pv2se0gzp6abrcuz4y_0000000005 ORDER BY "subjectID"</code></pre>
<p>Part of the hope is the additional record keeping in the operator nodes would let a very powerful query optimizer work over the flow before it gets translated to <code>SQL</code>. At the very least restricting to columns later used and folding selects together would be achievable. One should have a good chance at optimization as the representation is fairly high-level, and many of the operators are relational (meaning there are known legal transforms a query optimizer can use). The flow itself is represented as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(dq)</code></pre></div>
<pre><code>[1] "dbi_table('d') %.&gt;% extend(., probability := exp(\"assessmentTotal\" * 0.237) / sum(exp(\"assessmentTotal\" * 0.237)), count := count(1); p: subjectID) %.&gt;% extend(., rank := rank(); p: subjectID; o: probability) %.&gt;% extend(., isdiagnosis := \"rank\" &gt;= \"count\", diagnosis := \"surveyCategory\") %.&gt;% select_rows(., \"isdiagnosis\") %.&gt;% select_columns(., subjectID, diagnosis, probability) %.&gt;% order_by(., subjectID)"</code></pre>
<p>We can even pretty-format it:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cat</span>(<span class="kw">gsub</span>(<span class="st">"%.&gt;%"</span>, <span class="st">"%.&gt;%</span><span class="ch">\n</span><span class="st">   "</span>, <span class="kw">format</span>(dq), <span class="dt">fixed =</span> <span class="ot">TRUE</span>))</code></pre></div>
<pre><code>dbi_table('d') %.&gt;%
    extend(., probability := exp("assessmentTotal" * 0.237) / sum(exp("assessmentTotal" * 0.237)), count := count(1); p: subjectID) %.&gt;%
    extend(., rank := rank(); p: subjectID; o: probability) %.&gt;%
    extend(., isdiagnosis := "rank" &gt;= "count", diagnosis := "surveyCategory") %.&gt;%
    select_rows(., "isdiagnosis") %.&gt;%
    select_columns(., subjectID, diagnosis, probability) %.&gt;%
    order_by(., subjectID)</code></pre>
<p>And that is our weekend experiment.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DBI<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/DBI/topics/dbDisconnect">dbDisconnect</a></span>(my_db)</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>Note: <code>rquery</code> is only an experimental package. Also, it is not currently checked, but all <code>rquery</code> operators should be only used in “zero dependency mode” (never using a value created in the same operator or writing the same value twice) in the sense of <a href="https://www.rdocumentation.org/packages/seplyr/versions/0.5.0/topics/partition_mutate_qt"><code><a href="http://www.rdocumentation.org/packages/seplyr/topics/partition_mutate_qt">seplyr::partition_mutate_qt</a></code></a>. Again, the point was to see how quickly one can get a workable data transform pipeline in terms of Codd-inspired operators.</p>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
    <h2 class="hasAnchor">
<a href="#sidebar" class="anchor"></a>License</h2>
<p><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></p>
<h2>Developers</h2>
<ul class="list-unstyled">
<li>John Mount <br><small class="roles"> Author, maintainer </small> </li>
<li><a href="authors.html">All authors...</a></li>
</ul>
</div>

</div>


      <footer><div class="copyright">
  <p>Developed by John Mount.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://hadley.github.io/pkgdown/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  </body>
</html>
