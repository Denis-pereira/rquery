<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Relational Query Algebra for Data Manipulation • rquery</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- pkgdown --><link href="pkgdown.css" rel="stylesheet">
<script src="jquery.sticky-kit.min.js"></script><script src="pkgdown.js"></script><!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-vignette">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">rquery</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="reference/index.html">Reference</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="http://www.win-vector.com/">Sponsor: Win-Vector LLC</a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9">
    

    
    
<div class="contents">
<!-- README.md is generated from README.Rmd. Please edit that file -->
<p><a href="https://winvector.github.io/rquery/"><code>rquery</code></a> is an experiment/demonstration of a simplified sequenced query language based on <a href="https://en.wikipedia.org/wiki/Relational_algebra">Codd’s relational algebra</a> and not currently recommended for non-experimental (i.e., production) use. The goal of this experiment is to see if <code>SQL</code> would be more fun if it had a sequential data-flow or pipe notation.</p>
<p>To install: <code><a href="http://www.rdocumentation.org/packages/devtools/topics/install_github">devtools::install_github("WinVector/rquery")</a></code>.</p>
<p><a href="https://github.com/WinVector/rquery"><code>rquery</code></a> can be an excellent advanced <code>SQL</code> training tool (it shows how some very deep <code>SQL</code> by composing <code>rquery</code> operators). Currently <code>rquery</code> is biased towards the <code>Spark</code> and <code>PostgeSQL</code> <code>SQL</code> dialects.</p>
<p>There are many prior relational algebra inspired specialized query languages. Just a few include:</p>
<ul>
<li>
<a href="https://en.wikipedia.org/wiki/Alpha_(programming_language)"><code>Alpha</code></a> ~1971.</li>
<li>
<a href="https://en.wikipedia.org/wiki/QUEL_query_languages"><code>QUEL</code></a> ~1974.</li>
<li>
<a href="https://en.wikipedia.org/wiki/SQL"><code>SQL</code></a> ~1986.</li>
<li>
<a href="https://en.wikipedia.org/wiki/D_(data_language_specification)#Tutorial_D"><code>Tutorial D</code></a> ~2000.</li>
<li>
<a href="http://r-datatable.com/"><code>data.table</code></a> ~2006.</li>
<li>
<a href="https://msdn.microsoft.com/en-us/library/bb308959.aspx"><code>LINQ</code></a> ~2007.</li>
<li>
<a href="http://pandas.pydata.org"><code>pandas</code></a> ~2008.</li>
<li>
<a href="http://dplyr.tidyverse.org"><code>dplyr</code></a> ~2014.</li>
</ul>
<p><code>rquery</code> is realized as a thin translation to an underlying <code>SQL</code> provider. We are trying to put the Codd relational operators front and center (using the original naming, and back-porting <code>SQL</code> progress such as window functions to the appropriate relational operator).</p>
<p>The primary relational operators include:</p>
<ul>
<li>
<a href="https://winvector.github.io/rquery/reference/extend_nse.html"><code>extend()</code></a>. Extend adds derived columns to a relation table. With a sufficiently powerful <code>SQL</code> provider this includes ordered and partitioned window functions. This operator also includes built-in <a href="https://winvector.github.io/seplyr/"><code>seplyr</code></a>-style <a href="https://winvector.github.io/seplyr/articles/MutatePartitioner.html">assignment partitioning</a>.</li>
<li>
<a href="https://winvector.github.io/rquery/reference/project_nse.html"><code>project()</code></a>. Project is usually <em>portrayed</em> as the equivalent to column selection, though the original definition includes aggregation. In our opinion the original relational nature of the operator is best captured by moving <code>SQL</code>’s “<code>GROUP BY</code>” aggregation functionality.</li>
<li>
<a href="https://winvector.github.io/rquery/reference/natural_join.html"><code><a href="reference/natural_join.html">natural_join()</a></code></a>. This a specialized relational join operator, using all common columns as an equi-join condition.</li>
<li>
<a href="https://winvector.github.io/rquery/reference/theta_join_nse.html"><code>theta_join()</code></a>. This is the relational join operator allowing an arbitrary matching predicate.</li>
<li>
<a href="https://winvector.github.io/rquery/reference/theta_join_nse.html"><code>select_rows()</code></a>. This is Codd’s relational row selection. Obviously <code>select</code> alone is an over-used and now ambiguous term (for example: it is already used as the “doit” verb in <code>SQL</code> and the <em>column</em> selector in <code>dplyr</code>).</li>
<li>
<a href="https://winvector.github.io/rquery/reference/rename_columns.html"><code><a href="reference/rename_columns.html">rename_columns()</a></code></a>. This operator renames sets of columns.</li>
</ul>
<p>The primary non-relational (traditional <code>SQL</code>) operators are:</p>
<ul>
<li>
<a href="https://winvector.github.io/rquery/reference/select_columns.html"><code><a href="reference/select_columns.html">select_columns()</a></code></a>. This allows choice of columns (central to <code>SQL</code>), but is not a relational operator as it can damage row-uniqueness.</li>
<li>
<a href="https://winvector.github.io/rquery/reference/order_by.html"><code><a href="reference/order_by.html">order_by()</a></code></a>. Row order is not a concept in the relational algebra (and also not maintained in most <code>SQL</code> implementations). This operator is only useful when used with its <code>limit=</code> option, or as the last step as data comes out of the relation store and is moved to <code>R</code> (where row-order is usually maintained).</li>
</ul>
<p>The primary missing relational operators are:</p>
<ul>
<li>Union.</li>
<li>Direct set difference, anti-join.</li>
<li>Division.</li>
</ul>
<p>A great benefit of Codd’s relational algebra is it gives one concepts to decompose complex data transformations into sequences of simpler transformations. One reason <code>SQL</code> seems more complicated is <code>SQL</code>’s expression of sequencing as nested function composition. A lot of the gracefulness of the Codd theory can be recovered through the usual trick changing function composition notation from <code>g(f(x))</code> to <code>x . f() . g()</code>. This experiment is asking (and not for the first time): “what if <code>SQL</code> were piped (wrote composition as a left to right flow, instead of right to left nesting)?”</p>
<p>Let’s work a non-trivial example: the <code>dplyr</code> pipeline from <a href="http://www.win-vector.com/blog/2017/08/lets-have-some-sympathy-for-the-part-time-r-user/">Let’s Have Some Sympathy For The Part-time R User</a>.</p>
<p>First we set up the database and the original example data:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">"rquery"</span>)
use_spark &lt;-<span class="st"> </span><span class="ot">TRUE</span>

<span class="cf">if</span>(use_spark) {
  my_db &lt;-<span class="st"> </span>sparklyr<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/sparklyr/topics/spark-connections">spark_connect</a></span>(<span class="dt">version=</span><span class="st">'2.2.0'</span>, 
                                   <span class="dt">master =</span> <span class="st">"local"</span>)
} <span class="cf">else</span> {
  <span class="co"># driver &lt;- RPostgreSQL::PostgreSQL()</span>
  driver &lt;-<span class="st"> </span>RPostgres<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/RPostgres/topics/Postgres">Postgres</a></span>()
  my_db &lt;-<span class="st"> </span>DBI<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/DBI/topics/dbConnect">dbConnect</a></span>(driver,
                          <span class="dt">host =</span> <span class="st">'localhost'</span>,
                          <span class="dt">port =</span> <span class="dv">5432</span>,
                          <span class="dt">user =</span> <span class="st">'postgres'</span>,
                          <span class="dt">password =</span> <span class="st">'pg'</span>)
}


d &lt;-<span class="st"> </span><span class="kw"><a href="reference/dbi_copy_to.html">dbi_copy_to</a></span>(my_db, <span class="st">'d'</span>,
                 <span class="kw">data.frame</span>(
                   <span class="dt">subjectID =</span> <span class="kw">c</span>(<span class="dv">1</span>,                   
                                 <span class="dv">1</span>,
                                 <span class="dv">2</span>,                   
                                 <span class="dv">2</span>),
                   <span class="dt">surveyCategory =</span> <span class="kw">c</span>(
                     <span class="st">'withdrawal behavior'</span>,
                     <span class="st">'positive re-framing'</span>,
                     <span class="st">'withdrawal behavior'</span>,
                     <span class="st">'positive re-framing'</span>
                   ),
                   <span class="dt">assessmentTotal =</span> <span class="kw">c</span>(<span class="dv">5</span>,                 
                                       <span class="dv">2</span>,
                                       <span class="dv">3</span>,                  
                                       <span class="dv">4</span>),
                   <span class="dt">irrelevantCol1 =</span> <span class="st">"irrel1"</span>,
                   <span class="dt">irrelevantCol2 =</span> <span class="st">"irrel2"</span>,
                   <span class="dt">stringsAsFactors =</span> <span class="ot">FALSE</span>),
                 <span class="dt">temporary =</span> <span class="ot">TRUE</span>, 
                 <span class="dt">overwrite =</span> <span class="op">!</span>use_spark)

<span class="kw">print</span>(d)</code></pre></div>
<pre><code>## [1] "table('d')"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">d <span class="op">%.&gt;%</span>
<span class="st">  </span><span class="kw"><a href="reference/to_sql.html">to_sql</a></span>(.) <span class="op">%.&gt;%</span>
<span class="st">  </span>DBI<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/DBI/topics/dbGetQuery">dbGetQuery</a></span>(my_db, .) <span class="op">%.&gt;%</span>
<span class="st">  </span>knitr<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/knitr/topics/kable">kable</a></span>(.)</code></pre></div>
<table class="table">
<thead><tr class="header">
<th align="right">subjectID</th>
<th align="left">surveyCategory</th>
<th align="right">assessmentTotal</th>
<th align="left">irrelevantCol1</th>
<th align="left">irrelevantCol2</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="right">1</td>
<td align="left">withdrawal behavior</td>
<td align="right">5</td>
<td align="left">irrel1</td>
<td align="left">irrel2</td>
</tr>
<tr class="even">
<td align="right">1</td>
<td align="left">positive re-framing</td>
<td align="right">2</td>
<td align="left">irrel1</td>
<td align="left">irrel2</td>
</tr>
<tr class="odd">
<td align="right">2</td>
<td align="left">withdrawal behavior</td>
<td align="right">3</td>
<td align="left">irrel1</td>
<td align="left">irrel2</td>
</tr>
<tr class="even">
<td align="right">2</td>
<td align="left">positive re-framing</td>
<td align="right">4</td>
<td align="left">irrel1</td>
<td align="left">irrel2</td>
</tr>
</tbody>
</table>
<p>Now we write the original calculation in terms of the <code>rquery</code> operators.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">scale &lt;-<span class="st"> </span><span class="fl">0.237</span>

dq &lt;-<span class="st"> </span>d <span class="op">%.&gt;%</span>
<span class="st">  </span><span class="kw"><a href="reference/extend_nse.html">extend_nse</a></span>(.,
             probability <span class="op">:</span><span class="er">=</span>
<span class="st">               </span><span class="kw">exp</span>(assessmentTotal <span class="op">*</span><span class="st"> </span>scale)<span class="op">/</span>
<span class="st">               </span><span class="kw">sum</span>(<span class="kw">exp</span>(assessmentTotal <span class="op">*</span><span class="st"> </span>scale)),
             count <span class="op">:</span><span class="er">=</span><span class="st"> </span><span class="kw">count</span>(<span class="dv">1</span>),
             <span class="dt">partitionby =</span> <span class="st">'subjectID'</span>) <span class="op">%.&gt;%</span>
<span class="st">  </span><span class="kw"><a href="reference/extend_nse.html">extend_nse</a></span>(.,
             rank <span class="op">:</span><span class="er">=</span><span class="st"> </span><span class="kw">rank</span>(),
             <span class="dt">partitionby =</span> <span class="st">'subjectID'</span>,
             <span class="dt">orderby =</span> <span class="kw">c</span>(<span class="st">'probability'</span>, <span class="st">'surveyCategory'</span>))  <span class="op">%.&gt;%</span>
<span class="st">  </span><span class="kw"><a href="reference/rename_columns.html">rename_columns</a></span>(., <span class="st">'diagnosis'</span> <span class="op">:</span><span class="er">=</span><span class="st"> 'surveyCategory'</span>) <span class="op">%.&gt;%</span>
<span class="st">  </span><span class="kw"><a href="reference/select_rows_nse.html">select_rows_nse</a></span>(., rank <span class="op">==</span><span class="st"> </span>count) <span class="op">%.&gt;%</span>
<span class="st">  </span><span class="kw"><a href="reference/select_columns.html">select_columns</a></span>(., <span class="kw">c</span>(<span class="st">'subjectID'</span>, 
                      <span class="st">'diagnosis'</span>, 
                      <span class="st">'probability'</span>)) <span class="op">%.&gt;%</span>
<span class="st">  </span><span class="kw"><a href="reference/order_by.html">order_by</a></span>(., <span class="st">'subjectID'</span>)</code></pre></div>
<p>We then generate our result:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dq <span class="op">%.&gt;%</span>
<span class="st">  </span><span class="kw"><a href="reference/to_sql.html">to_sql</a></span>(., <span class="dt">source_limit =</span> <span class="dv">1000</span>) <span class="op">%.&gt;%</span>
<span class="st">  </span>DBI<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/DBI/topics/dbGetQuery">dbGetQuery</a></span>(my_db, .) <span class="op">%.&gt;%</span>
<span class="st">  </span>knitr<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/knitr/topics/kable">kable</a></span>(.)</code></pre></div>
<table class="table">
<thead><tr class="header">
<th align="right">subjectID</th>
<th align="left">diagnosis</th>
<th align="right">probability</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="right">1</td>
<td align="left">withdrawal behavior</td>
<td align="right">0.6706221</td>
</tr>
<tr class="even">
<td align="right">2</td>
<td align="left">positive re-framing</td>
<td align="right">0.5589742</td>
</tr>
</tbody>
</table>
<p>We see we quickly reproduced the original result using the new database operators. This means such a calculation could easily be performed at a “big data” scale (using a database or <code>Spark</code>; in this case we would not take the results back, but instead use <code>CREATE TABLE tname AS</code> to build a remote materialized view of the results).</p>
<p>The actual <code>SQL</code> query that produces the result is, in fact, quite involved:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cat</span>(<span class="kw"><a href="reference/to_sql.html">to_sql</a></span>(dq, <span class="dt">source_limit =</span> <span class="dv">1000</span>))</code></pre></div>
<pre><code>SELECT * FROM (
 SELECT
  `subjectID`,
  `diagnosis`,
  `probability`
 FROM (
  SELECT * FROM (
   SELECT
    `subjectID` AS `subjectID`,
    `surveyCategory` AS `diagnosis`,
    `probability` AS `probability`,
    `count` AS `count`,
    `rank` AS `rank`
   FROM (
    SELECT
     `subjectID`,
     `surveyCategory`,
     `probability`,
     `count`,
     rank() OVER (  PARTITION BY `subjectID` ORDER BY `probability`, `surveyCategory` ) AS `rank`
    FROM (
     SELECT
      `subjectID`,
      `surveyCategory`,
      `assessmentTotal`,
      exp(`assessmentTotal` * 0.237) / sum(exp(`assessmentTotal` * 0.237)) OVER (  PARTITION BY `subjectID` ) AS `probability`,
      count(1) OVER (  PARTITION BY `subjectID` ) AS `count`
     FROM (
      SELECT
       `d`.`subjectID`,
       `d`.`surveyCategory`,
       `d`.`assessmentTotal`
      FROM
       `d` LIMIT 1000
      ) tsql_0000
     ) tsql_0001
   ) tsql_0002
  ) tsql_0003
  WHERE `rank` = `count`
 ) tsql_0004
) tsql_0005 ORDER BY `subjectID`</code></pre>
<p>The query is large, but due to its regular structure it should be very amenable to query optimization.</p>
<p>A feature to notice is: the query was automatically restricted to just columns actually needed from the source table to complete the calculation. This has the possibilty of decreasing data volume and greatly speeding up query performance. Our <a href="https://github.com/WinVector/rquery/blob/master/extras/PerfTest.md">initial experiments</a> show <code>rquery</code> to be 25% faster than <code>dplyr</code> on a synthetic problem.</p>
<p>The above optimization is possible because the <code>rquery</code> representation is an intelligible tree of nodes, so we can interrogate the tree for facts about the query. For example:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="reference/column_names.html">column_names</a></span>(dq)</code></pre></div>
<pre><code>## [1] "diagnosis"   "probability" "subjectID"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="reference/tables_used.html">tables_used</a></span>(dq)</code></pre></div>
<pre><code>## [1] "d"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="reference/columns_used.html">columns_used</a></span>(dq)</code></pre></div>
<pre><code>## [1] "`d`.`subjectID`"       "`d`.`surveyCategory`"  "`d`.`assessmentTotal`"</code></pre>
<p>Part of the plan is: the additional record-keeping in the operator nodes would let a potentially powerful query optimizer work over the flow before it gets translated to <code>SQL</code> (perhaps an extension of or successor to <a href="https://winvector.github.io/seplyr/"><code>seplyr</code></a>, which re-plans over <code><a href="http://dplyr.tidyverse.org/reference/mutate.html">dplyr::mutate()</a></code> expressions). At the very least restricting to columns later used and folding selects together would be achievable. One should have a good chance at optimization as the representation is fairly high-level, and many of the operators are relational (meaning there are known legal transforms a query optimizer can use). The flow itself is represented as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cat</span>(<span class="kw">format</span>(dq))</code></pre></div>
<pre><code>table('d') %.&gt;%
 extend(.,
  probability := exp(assessmentTotal * scale) / sum(exp(assessmentTotal * scale)),
  count := count(1),
  p= subjectID) %.&gt;%
 extend(.,
  rank := rank(),
  p= subjectID,
  o= probability, surveyCategory) %.&gt;%
 rename(.,
  c('diagnosis' := 'surveyCategory')) %.&gt;%
 select_rows(., rank == count) %.&gt;%
 select_columns(., subjectID, diagnosis, probability) %.&gt;%
 order_by(., subjectID)</code></pre>
<p>We also can stand <code>rquery</code> up on non-<code>DBI</code> sources such as <a href="https://github.com/WinVector/rquery/blob/master/extras/SparkRExample.md"><code>SparkR</code></a> and perhaps even <a href="https://github.com/WinVector/rquery/blob/master/extras/data_table.md"><code>data.table</code></a>.</p>
<p>And that is our experiment.</p>
<p>We are looking for funding and partners to take this system further (including: finishing functionality, documentation, training materials, test materials, acceptance procedures, and porting to more back-ends). It is our opinion that a query generator specialized to large scale databases and <code>Spark</code> will serve <code>R</code> users very well.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="cf">if</span>(use_spark) {
  sparklyr<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/sparklyr/topics/spark-connections">spark_disconnect</a></span>(my_db)
} <span class="cf">else</span> {
  DBI<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/DBI/topics/dbDisconnect">dbDisconnect</a></span>(my_db)
}</code></pre></div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
    <h2 class="hasAnchor">
<a href="#sidebar" class="anchor"></a>Links</h2>
<ul class="list-unstyled">
<li>Browse source code at <br><a href="https://github.com/WinVector/rquery/">https://​github.com/​WinVector/​rquery/​</a>
</li>
</ul>
<h2>License</h2>
<p><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></p>
<h2>Developers</h2>
<ul class="list-unstyled">
<li>John Mount <br><small class="roles"> Author, maintainer </small> </li>
<li><a href="authors.html">All authors...</a></li>
</ul>
</div>

</div>


      <footer><div class="copyright">
  <p>Developed by John Mount.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://hadley.github.io/pkgdown/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  </body>
</html>
