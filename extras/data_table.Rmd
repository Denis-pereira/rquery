---
title: "data.table backend for rquery"
author: "John Mount, Win-Vector LLC"
date: "05/29/2018"
output: github_document
---

We can work an example similar to the [`rquery`](https://winvector.github.io/rquery/) [example](https://winvector.github.io/rquery/index.html) using a [`data.table`](http://r-datatable.com/) 
back-end.

```{r}
library("ggplot2")
library("microbenchmark")
library("dplyr")
library("rquery")
# load data.table second so its definiton of := wins
library("data.table")
library("dtplyr")
source("data_table.R") # our example rquery data.table back-end
```


```{r}
# data example
dL <- build_frame(
   "subjectID", "surveyCategory"     , "assessmentTotal" |
   1          , "withdrawal behavior", 5                 |
   1          , "positive re-framing", 2                 |
   2          , "withdrawal behavior", 3                 |
   2          , "positive re-framing", 4                 )
```


```{r}
scale <- 0.237

# example rquery pipeline
rquery_pileline <- local_td(dL) %.>%
  extend_nse(.,
             one := 1) %.>%
  extend_nse(.,
             probability :=
               exp(assessmentTotal * scale)/
               sum(exp(assessmentTotal * scale)),
             count := sum(one),
             rank := rank(probability, surveyCategory),
             partitionby = 'subjectID') %.>%
  extend_nse(.,
             isdiagnosis := rank == count,
             diagnosis := surveyCategory) %.>%
  select_rows_nse(., 
                  isdiagnosis == TRUE) %.>%
  select_columns(., 
                 c('subjectID', 'diagnosis', 'probability')) %.>%
  orderby(., 'subjectID')
```

Show expanded form of query tree.

```{r, comment=""}
cat(format(rquery_pileline))
```


```{r}
# execute
# https://stackoverflow.com/questions/10527072/using-data-table-package-inside-my-own-package
#.datatable.aware <- TRUE

ex_data_table(rquery_pileline) %.>%
  knitr::kable(.)
```

`dplyr` pipeline.


```{r}
scale <- 0.237

dplyr_pipeline <- . %>% group_by(subjectID) %>%
  mutate(probability =
           exp(assessmentTotal * scale)/
           sum(exp(assessmentTotal * scale), na.rm = TRUE)) %>%
  arrange(probability, surveyCategory) %>%
  filter(row_number() == n()) %>%
  ungroup() %>%
  rename(diagnosis = surveyCategory) %>%
  select(subjectID, diagnosis, probability) %>%
  arrange(subjectID) 

dL %>% 
  dplyr_pipeline %>%
  knitr::kable()
```

Try `dtplyr`.

```{r, error = TRUE}
data.table::as.data.table(dL) %>% 
  dplyr_pipeline
```


Timings.

```{r}
# fatten up data.frame a bit
dL <- dL[rep(seq_len(nrow(dL)), 100000), , drop = FALSE]
dL$subjectID <- paste(dL$subjectID, (1+seq_len(nrow(dL))) %/% 2, sep = "_")
for(i in seq_len(10)) {
  dL[[paste0("irrelevantCol", i)]] <- runif(nrow(dL))
}

# show we are working on the new larger data
system.time(print(nrow(ex_data_table(rquery_pileline))))

system.time(print(nrow(dplyr_pipeline(dL))))
```

```{r}
timings <- microbenchmark(
  nrow(ex_data_table(rquery_pileline)),
  nrow(dplyr_pipeline(dL)))
```


```{r}
print(timings)

# summarize by hand using rquery database connector
summary_pipeline <- timings %.>%
  as.data.frame(.) %.>%
  project_nse(., groupby = "expr", mean = avg(time)) 
timings %.>% 
  as.data.frame(.) %.>%
  summary_pipeline %.>%
  knitr::kable(.)

autoplot(timings)

WVPlots::ScatterBoxPlotH(as.data.frame(timings), "time", "expr", "runtime by expression in nanoseconds")
```





