---
title: "QTiming"
author: "Win-Vector LLC"
date: "1/7/2018"
output: github_document
---

Let's time both [`rquery`](https://winvector.github.io/rquery/) and [`dplyr`]( https://CRAN.R-project.org/package=dplyr) on a non-trivial example.  

First let's load our
packages, establish a database connection, and declare an [`rquery` ad hoc execution service](https://winvector.github.io/rquery/articles/AdHocQueries.html) (the "`winvector_temp_db_handle`").

```{r dbsetup}
library("rquery")
library("dplyr")
library("microbenchmark")
library("rbenchmark")
library("ggplot2")

db <- DBI::dbConnect(RPostgres::Postgres(),
                     host = 'localhost',
                     port = 5432,
                     user = 'postgres',
                     password = 'pg')
winvector_temp_db_handle <- list(db = db)
```

We now build and extended version of the example from [Letâ€™s Have Some Sympathy For The Part-time R User](http://www.win-vector.com/blog/2017/08/lets-have-some-sympathy-for-the-part-time-r-user/).

```{r data}
nrep <- 10000

dL <- data.frame(
  subjectID = c(1,                   
                1,
                2,                   
                2),
  surveyCategory = c(
    'withdrawal behavior',
    'positive re-framing',
    'withdrawal behavior',
    'positive re-framing'
  ),
  assessmentTotal = c(5,                 
                      2,
                      3,                  
                      4),
  stringsAsFactors = FALSE)
norig <- nrow(dL)
dL <- dL[rep(seq_len(norig), nrep), , drop=FALSE]
dL$subjectID <- paste((seq_len(nrow(dL)) -1)%/% norig,
                      dL$subjectID, 
                      sep = "_")
rownames(dL) <- NULL
head(dL)

dR <- rquery::dbi_copy_to(db, 'dR',
                  dL,
                  temporary = TRUE, 
                  overwrite = TRUE)
cdata::qlook(db, dR$table_name)

dT <- dplyr::tbl(db, dR$table_name)
dplyr::glimpse(dT)
```

Now we declare our operation pipelines, both on local (in-memory `data.frame`) and
remote (already in a database) data.

```{r query}
scale <- 0.237

# this is a function, 
# so body not evaluated until used
rquery_pipeline <- . := {
  extend_nse(.,
             probability :=
               exp(assessmentTotal * scale)/
               sum(exp(assessmentTotal * scale)),
             count := count(1),
             partitionby = 'subjectID') %.>%
    extend_nse(.,
               rank := rank(),
               partitionby = 'subjectID',
               orderby = c('probability', 'surveyCategory'))  %.>%
    rename_columns(., 'diagnosis' := 'surveyCategory') %.>%
    select_rows_nse(., rank == count) %.>%
    select_columns(., c('subjectID', 
                        'diagnosis', 
                        'probability')) %.>%
    orderby(., 'subjectID') 
}



rquery_local <- function() {
 dL %.>% 
    rquery_pipeline %.>%
    as.data.frame(.) # force execution
}

rquery_database <- function() {
 dR %.>% 
    rquery_pipeline %.>% 
    to_sql(., db) %.>% 
    DBI::dbGetQuery(db, .) %.>%
    as.data.frame(.) # shouldn't be needed
}

# this is a function, 
# so body not evaluated until used
dplyr_pipeline <- . %>%
  group_by(subjectID) %>%
    mutate(probability =
             exp(assessmentTotal * scale)/
             sum(exp(assessmentTotal * scale)), na.rm = TRUE) %>%
    arrange(probability, surveyCategory) %>%
    filter(row_number() == n()) %>%
    ungroup() %>%
    rename(diagnosis = surveyCategory) %>%
    select(subjectID, diagnosis, probability) %>%
    arrange(subjectID)
  
dplyr_local <- function() {
  dL %>% 
    dplyr_pipeline
}

dplyr_database <- function() {
  dT %>% 
    dplyr_pipeline %>%
    collect()
}
```

Let's inspect the functions.

```{r show}
head(rquery_local())

head(rquery_database())

head(dplyr_local())

head(dplyr_database())
```

I have tried to get rid of the warnings that
the dplyr database pipeline is producing, but adding the "`na.rm = TRUE`" appears to have no effect.

Now let's measure the speeds with `microbenchmark`.

```{r timings, warning=FALSE}
# check from: 
# https://cran.r-project.org/web/packages/microbenchmark/microbenchmark.pdf
my_check <- function(values) {
  all(sapply(values[-1], 
             function(x) identical(values[[1]], x)))
}

tm <- microbenchmark(
  nrow(rquery_local()),
  nrow(rquery_database()),
  nrow(dplyr_local()),
  nrow(dplyr_database()),
  check=my_check)
print(tm)
autoplot(tm)
```

`rquery` appears to be fast.  The extra time for "`rquery` local" is because `rquery`
doesn't *really* have a local mode, it has to copy the data to the database and back
in that case.  I currently guess `rquery` and `dplyr` are both picking up parallelism 
in the database.

Let's re-measure with `rbenchmark`,

```{r timingsr,  warning=FALSE}
tb <- benchmark(
  rquery_local = { nrow(rquery_local()) },
  rquery_database = { nrow(rquery_database()) },
  dplyr_local = { nrow(dplyr_local()) },
  dplyr_database = { nrow(dplyr_database()) }
)
knitr::kable(tb)
```

And that is it.  `rquery` isn't slow, even on local data!

```{r dbcleanup}
winvector_temp_db_handle <- NULL
DBI::dbDisconnect(db)
```
